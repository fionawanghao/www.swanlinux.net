<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Swan]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.swanlinux.net/"/>
  <updated>2015-05-23T23:10:55.746Z</updated>
  <id>http://www.swanlinux.net/</id>
  
  <author>
    <name><![CDATA[Nmred]]></name>
    <email><![CDATA[nmred_2008@126.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[《C++ Primer Plus(第6版)》第四章 复合类型]]></title>
    <link href="http://www.swanlinux.net/2015/05/04/cplus_primer_03/"/>
    <id>http://www.swanlinux.net/2015/05/04/cplus_primer_03/</id>
    <published>2015-05-04T05:13:16.000Z</published>
    <updated>2015-04-24T00:47:09.290Z</updated>
    <content type="html"><![CDATA[<p>\1. 编写一个C++程序，如下述输出示例所示的那样请求并显示信息：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>What <span class="keyword">is</span> your <span class="keyword">first</span> <span class="property">name</span>? Brtty Sue
What <span class="keyword">is</span> your <span class="keyword">last</span> <span class="property">name</span>? Yewe
What letter grade do you deserve? B
What <span class="keyword">is</span> you age? <span class="number">22</span>
Name: Yewe, Betty Sue
Grade: C
Age: <span class="number">22</span>
</pre></td></tr></table></figure>

<p>注意， 该程序应该接受的名字包含多个单词。另外，程序将向下调整成绩，即向上调一个字母。假设用户请求A、B或C, 所以不必担心D和F之间的空档。</p>
<p>\2. 修改程序清单4.4， 使用 C++ string 类而不是char数组</p>
<p>\3. 编写一个程序，它要求用户首先输入其名，然后输入其姓</p>
]]></content>
    
    
      <category term="C++" scheme="http://www.swanlinux.net/tags/C++/"/>
    
      <category term="《C++ Primer Plus(第6版)》练习" scheme="http://www.swanlinux.net/categories/%E3%80%8AC++%20Primer%20Plus(%E7%AC%AC6%E7%89%88)%E3%80%8B%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《C++ Primer Plus(第6版)》第二章 开始学习C++]]></title>
    <link href="http://www.swanlinux.net/2015/04/30/cplus_primer_02/"/>
    <id>http://www.swanlinux.net/2015/04/30/cplus_primer_02/</id>
    <published>2015-04-30T05:13:16.000Z</published>
    <updated>2015-04-23T20:51:35.717Z</updated>
    <content type="html"><![CDATA[<p>\1. 编写一个C++程序，它显示您的姓名和地址？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;iostream&gt;</span>

<span class="keyword">int</span> main(<span class="keyword">void</span>) {
    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;
    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Name: nmred"</span> &lt;&lt; endl;
    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Address: Hai Dian Bei Jing"</span> &lt;&lt; endl;
    <span class="keyword">return</span> <span class="number">0</span>;
}
</pre></td></tr></table></figure>

<p>\2. 编写一个C++程序，它要求用户输入一个以long 为单位的距离，然后转化为码(1 long = 220码)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;iostream&gt;</span>

<span class="keyword">int</span> main(<span class="keyword">void</span>) {
    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;
    <span class="keyword">int</span> longSize = <span class="number">0</span>;
    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Please input long size:"</span>;
    <span class="built_in">cin</span> &gt;&gt; longSize;

    <span class="built_in">cout</span> &lt;&lt; <span class="string">"After convert value:"</span> &lt;&lt; longSize * <span class="number">220</span> &lt;&lt; endl;
    <span class="keyword">return</span> <span class="number">0</span>;
}
</pre></td></tr></table></figure>

<p>\3. 编写一个C++程序，它使用了3个用户定义的函数（包括main）并生成下面的输出：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>Three blind nice
Three blind nice
See how they <span class="command">run</span>
See how they <span class="command">run</span>
</pre></td></tr></table></figure>

<p>其中一个函数要调用两次，该函数生成输出的前两行，另一个函数也被调用两次，并生成其余的输出。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;iostream&gt;</span>

<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;

<span class="keyword">void</span> printBlind() {
    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Three blind nice"</span> &lt;&lt; endl;
}

<span class="keyword">void</span> printRun() {
    <span class="built_in">cout</span> &lt;&lt; <span class="string">"See how they run"</span> &lt;&lt; endl;
}

<span class="keyword">int</span> main(<span class="keyword">void</span>) {
    printBlind();
    printBlind();

    printRun();
    printRun();
    <span class="keyword">return</span> <span class="number">0</span>;
}
</pre></td></tr></table></figure>

<p>\4. 编写一个程序，让用户输入其年龄，然后显示该年龄包含多少个月，如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">Enter</span> your age : <span class="number">29</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;iostream&gt;</span>

<span class="keyword">int</span> main(<span class="keyword">void</span>) {
    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;

    <span class="keyword">int</span> age;
    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter your age:"</span>;
    <span class="built_in">cin</span> &gt;&gt; age;

    <span class="built_in">cout</span> &lt;&lt; <span class="string">"You age mouth: "</span> &lt;&lt; age * <span class="number">12</span> &lt;&lt; endl;

    <span class="keyword">return</span> <span class="number">0</span>;
}
</pre></td></tr></table></figure>

<p>\5. 编写一个程序， 其中的main() 调用一个用户定义的函数(以摄氏温度值为参数，并返回相应的华氏温度值)。该程序按下面的格式要求用户输入摄氏温度值，并显示结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>Please enter a Celsius <span class="keyword">value</span>: <span class="number">20</span>
<span class="number">20</span> degrees Celsius <span class="keyword">is</span> <span class="number">68</span> degrees Fahrenheit
</pre></td></tr></table></figure>

<p>下面是转换公式:</p>
<p>华氏温度 = 1.8 * 摄氏温度 + 32.0</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;iostream&gt;</span>

<span class="keyword">int</span> main(<span class="keyword">void</span>) {
    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;

    <span class="keyword">int</span> celsius;
    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter a Celsius value:"</span>;
    <span class="built_in">cin</span> &gt;&gt; celsius;

    <span class="built_in">cout</span> &lt;&lt; celsius &lt;&lt; <span class="string">" degrees Celsius is "</span> &lt;&lt; celsius * <span class="number">1.8</span> + <span class="number">32</span> &lt;&lt; <span class="string">" degrees Fahrenheit"</span> &lt;&lt; endl;

    <span class="keyword">return</span> <span class="number">0</span>;
}
</pre></td></tr></table></figure>

<p>\6. 编译一个程序，其main() 调用一个用户定义的函数(以光年值为参数，并返回对应天文单位的值). 该程序按下面的格式要求用户输入光年值，并显示结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>Enter <span class="operator">the</span> <span class="built_in">number</span> <span class="operator">of</span> light years: <span class="number">4.2</span>
<span class="number">4.2</span> light years = <span class="number">265608</span> astronomical units.
</pre></td></tr></table></figure>

<p>天文单位是从地球到太阳的平均距离（约150000000公里或93000000英里）, 光年是光一年走的距离(约10万亿公里或6万亿英里)（除太阳外，最近的恒星大约离地球4.2光年）。请使用double类型， 转化公式为：</p>
<p>1光年 = 63240 天文单位</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;iostream&gt;</span>

<span class="keyword">double</span> convert(<span class="keyword">double</span> years) {
    <span class="keyword">return</span> years * <span class="number">63240</span>;
}

<span class="keyword">int</span> main(<span class="keyword">void</span>) {
    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;
    <span class="keyword">double</span> year;
    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter the number of light years:"</span>;
    <span class="built_in">cin</span> &gt;&gt; year;
    <span class="built_in">cout</span> &lt;&lt; year &lt;&lt; <span class="string">" light years = "</span> &lt;&lt; convert(year) &lt;&lt; <span class="string">" astronomical units."</span> &lt;&lt; endl;

    <span class="keyword">return</span> <span class="number">0</span>;
}
</pre></td></tr></table></figure>

<p>\7. 编写一个程序，要求用户输入小时数和分钟数，在mian() 函数中，将这两个值传递给一个void函数，后者以下面这样的格式显示这两个值：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>Enter <span class="operator">the</span> <span class="built_in">number</span> <span class="operator">of</span> hours: <span class="number">9</span>
Enter <span class="operator">the</span> <span class="built_in">number</span> <span class="operator">of</span> minutes: <span class="number">28</span>
Time: <span class="number">9</span>:<span class="number">28</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td><td class="code"><pre><span class="preprocessor">#include &lt;iostream&gt;</span>

<span class="keyword">int</span> main(<span class="keyword">void</span>) {
    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;
    <span class="keyword">int</span> hour = -<span class="number">1</span>;
    <span class="keyword">int</span> minute = -<span class="number">1</span>;

    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter the number of hours:"</span>;
    <span class="built_in">cin</span> &gt;&gt; hour;
    <span class="keyword">if</span> (!<span class="built_in">cin</span>) {
        <span class="built_in">cin</span>.clear();
        <span class="keyword">while</span> (<span class="built_in">cin</span>.get() != <span class="string">'\n'</span>) {
            <span class="keyword">continue</span>;
        }
    }
    <span class="keyword">while</span> (hour &gt; <span class="number">24</span> || hour &lt; <span class="number">0</span>) {
        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter the number of hours:"</span>;
        <span class="built_in">cin</span> &gt;&gt; hour;
    }
    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter the number of minutes:"</span>;
    <span class="built_in">cin</span> &gt;&gt; minute;
    <span class="keyword">if</span> (!<span class="built_in">cin</span>) {
        <span class="built_in">cin</span>.clear();
        <span class="keyword">while</span> (<span class="built_in">cin</span>.get() != <span class="string">'\n'</span>) {
            <span class="keyword">continue</span>;
        }
    }
    <span class="keyword">while</span> (minute &gt; <span class="number">60</span> || minute &lt; <span class="number">0</span>) {
        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter the number of minutes:"</span>;
        <span class="built_in">cin</span> &gt;&gt; minute;
    }

    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Time:"</span> &lt;&lt; hour &lt;&lt; <span class="string">":"</span> &lt;&lt; minute &lt;&lt; endl;

    <span class="keyword">return</span> <span class="number">0</span>;
}
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="C++" scheme="http://www.swanlinux.net/tags/C++/"/>
    
      <category term="《C++ Primer Plus(第6版)》练习" scheme="http://www.swanlinux.net/categories/%E3%80%8AC++%20Primer%20Plus(%E7%AC%AC6%E7%89%88)%E3%80%8B%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《快学scala》第十六章 XML 处理]]></title>
    <link href="http://www.swanlinux.net/2014/10/24/scala_note_16/"/>
    <id>http://www.swanlinux.net/2014/10/24/scala_note_16/</id>
    <published>2014-10-24T11:42:16.000Z</published>
    <updated>2015-05-23T22:03:07.643Z</updated>
    <content type="html"><![CDATA[<p>\1. <fred/>(0) 得到什么？<fred/>(0)(0)呢？为什么？</p>
<p>\2. 如下代码的值是什么？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>

</pre></td></tr></table></figure>

<p>\3. </p>
]]></content>
    
    
      <category term="scala" scheme="http://www.swanlinux.net/tags/scala/"/>
    
      <category term="《快学scala》练习" scheme="http://www.swanlinux.net/categories/%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《快学scala》第十五章 注解]]></title>
    <link href="http://www.swanlinux.net/2014/10/22/scala_note_15/"/>
    <id>http://www.swanlinux.net/2014/10/22/scala_note_15/</id>
    <published>2014-10-22T11:42:16.000Z</published>
    <updated>2015-05-23T22:03:07.643Z</updated>
    <content type="html"><![CDATA[<p>\1. 编写四个Junit测试案例，分别使用带或不带某个函数的@Test注解。用 Junit执行这些测试。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="keyword">import</span> org.junit.Test

<span class="class"><span class="keyword">class</span> <span class="title">ScalaTest</span> {</span>
  <span class="annotation">@Test</span>
  <span class="keyword">def</span> test1() {
    println(<span class="string">"test1"</span>)
  }

  <span class="annotation">@Test</span>(timeout = <span class="number">1</span>L)
  <span class="keyword">def</span> test2() {
    println(<span class="string">"test2"</span>)
  }
}
</pre></td></tr></table></figure>

<p>\2. 创建一个类的示例，展示注解可以出现的所有位置。用@deprecated作为你的示例注解。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="annotation">@deprecated</span>
<span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span>
  <span class="annotation">@deprecated</span>
  <span class="keyword">val</span> t = <span class="string">"unuse"</span>
  
  <span class="annotation">@deprecated</span>(message = <span class="string">"unuse"</span>)
  <span class="keyword">def</span> hello() {
      println(<span class="string">"hello"</span>)
  }   
} 

<span class="annotation">@deprecated</span>
<span class="class"><span class="keyword">object</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">App</span> {</span>
  <span class="keyword">val</span> t = <span class="keyword">new</span> Test()
  t.hello 
}
</pre></td></tr></table></figure>

<p>\3. Scala 类库中的那些注解用到了元注解@param, @field, @getter, @setter, @beanGetter或@beanSetter?</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>略
</pre></td></tr></table></figure>

<p>\4. 编写一个Scala方法sum，带有可变长度的整型参数，返回所有参数之和。从Java调用该方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>import annotation.varargs
class sumTest {
  @varargs
  def sum(nums: Int*): Int = {
    nums.sum
  }
}

<span class="keyword">public</span> <span class="keyword">class</span> Hello {
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        sumTest t = <span class="keyword">new</span> sumTest();
        System.<span class="keyword">out</span>.println(t.sum(<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>));
    }
}
</pre></td></tr></table></figure>

<p>\5. 编写一个返回包含某文件所有行的字符串的方法。从Java调用该方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre>import io.Source

<span class="keyword">object</span> FileTest {
  def read(path: String): String = {
    Source.fromFile(path).mkString
  }
}

<span class="keyword">public</span> <span class="keyword">class</span> FileRead {
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {
        System.<span class="keyword">out</span>.println(FileTest.read(<span class="string">"/tmp/a.txt"</span>));
    }
}
</pre></td></tr></table></figure>

<p>\6. 编写一个Scala对象，该对象带有一个易失(volatile)的Boolean字段。让某一个线程睡眠一段时间，之后将该字段设为true, 打印消息，然后退出。而另一个线程不停地检查该字段是否为true。 如果是，它将打印一个消息并退出。如果不是，它将短暂睡眠，然后重试。如果变量不是易失的，会发生什么？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="code"><pre><span class="keyword">import</span> scala.actors.Actor
<span class="class"><span class="keyword">class</span> <span class="title">T1</span><span class="params">(obj: Obj)</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  <span class="keyword">def</span> act() {
    println(<span class="string">"T1 is waiting"</span>)
    Thread.sleep(<span class="number">5000</span>)
    obj.flag = <span class="keyword">true</span>
    println(<span class="string">"T1 set flag = true"</span>)
  }
}

<span class="class"><span class="keyword">class</span> <span class="title">T2</span><span class="params">(obj: Obj)</span> <span class="keyword">extends</span> <span class="title">Actor</span> {</span>
  <span class="keyword">def</span> act() {
    <span class="keyword">var</span> f = <span class="keyword">true</span>
    <span class="keyword">while</span> (f) {
      <span class="keyword">if</span> (obj.flag) {
        println(<span class="string">"T2 is end"</span>)
        f = <span class="keyword">false</span>
      } <span class="keyword">else</span> {
        println(<span class="string">"T2 is waiting"</span>)
        Thread.sleep(<span class="number">1000</span>)
      }
    }
  }
}

<span class="class"><span class="keyword">class</span> <span class="title">Obj</span> {</span>
  <span class="annotation">@volatile</span> 
  <span class="keyword">var</span> flag: Boolean = <span class="keyword">false</span>
}

<span class="class"><span class="keyword">object</span> <span class="title">Test</span> {</span>
  <span class="keyword">def</span> main(args : Array[String]) {
    <span class="keyword">val</span> obj = <span class="keyword">new</span> Obj()
    <span class="keyword">val</span> t1 = <span class="keyword">new</span> T1(obj)
    <span class="keyword">val</span> t2 = <span class="keyword">new</span> T2(obj)
    t1.start()
    t2.start()
  }
}
</pre></td></tr></table></figure>

<p>\7. 给出一个示例，展示如果方法可被重写，则尾递归优化为非法。</p>
<p>\8. 将allDifferent 方法添加到对象，编译并检查字节码。@specialized 注解产生了哪些方法？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>object SpecTest {
  def allDifferent[<span class="link_label">@specialized T</span>](<span class="link_url">x:T,y:T,z:T</span>) = x != y && x!= z && y != z
}
</pre></td></tr></table></figure>

<p>用javap 得到</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre>[root<span class="annotation">@devswan</span> scala]# javap ../../../target/scala-<span class="number">2.10</span>/classes/SpecTest\$.class 
Compiled from <span class="string">"spec.scala"</span>
<span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SpecTest</span>$ {</span>
  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SpecTest$ MODULE$;
  <span class="keyword">public</span> <span class="keyword">static</span> {};
  <span class="keyword">public</span> &lt;T extends java/lang/Object&gt; <span class="keyword">boolean</span> <span class="title">allDifferent</span>(T, T, T);
  <span class="keyword">public</span> <span class="keyword">boolean</span> allDifferent$mZc$<span class="title">sp</span>(<span class="keyword">boolean</span>, <span class="keyword">boolean</span>, <span class="keyword">boolean</span>);
  <span class="keyword">public</span> <span class="keyword">boolean</span> allDifferent$mBc$<span class="title">sp</span>(<span class="keyword">byte</span>, <span class="keyword">byte</span>, <span class="keyword">byte</span>);
  <span class="keyword">public</span> <span class="keyword">boolean</span> allDifferent$mCc$<span class="title">sp</span>(<span class="keyword">char</span>, <span class="keyword">char</span>, <span class="keyword">char</span>);
  <span class="keyword">public</span> <span class="keyword">boolean</span> allDifferent$mDc$<span class="title">sp</span>(<span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>);
  <span class="keyword">public</span> <span class="keyword">boolean</span> allDifferent$mFc$<span class="title">sp</span>(<span class="keyword">float</span>, <span class="keyword">float</span>, <span class="keyword">float</span>);
  <span class="keyword">public</span> <span class="keyword">boolean</span> allDifferent$mIc$<span class="title">sp</span>(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>);
  <span class="keyword">public</span> <span class="keyword">boolean</span> allDifferent$mJc$<span class="title">sp</span>(<span class="keyword">long</span>, <span class="keyword">long</span>, <span class="keyword">long</span>);
  <span class="keyword">public</span> <span class="keyword">boolean</span> allDifferent$mSc$<span class="title">sp</span>(<span class="keyword">short</span>, <span class="keyword">short</span>, <span class="keyword">short</span>);
  <span class="keyword">public</span> <span class="keyword">boolean</span> allDifferent$mVc$<span class="title">sp</span>(scala.runtime.BoxedUnit, scala.runtime.BoxedUnit, scala.runtime.BoxedUnit);
}
</pre></td></tr></table></figure>

<p>\9. Range.foreach 方法被注解为 @specialized(Unit)。为什么？ 通过以下命令检查字节码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>javap -classpath /path/to/scala/lib/scala-library<span class="preprocessor">.jar</span> scala<span class="preprocessor">.collection</span><span class="preprocessor">.immutable</span><span class="preprocessor">.Range</span>
</pre></td></tr></table></figure>

<p>并考虑Function1 上的@specialized 注解。点击ScalaDoc 中的Function1.scala链接进行查看</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>......
<span class="class"><span class="keyword">trait</span> <span class="title">Function1</span>[@<span class="title">specialized</span><span class="params">(scala.Int, scala.Long, scala.Float, scala.Double/*, scala.AnyRef*/)</span> -<span class="title">T1</span>, @<span class="title">specialized</span><span class="params">(scala.Unit, scala.Boolean, scala.Int, scala.Float, scala.Long, scala.Double/*, scala.AnyRef*/)</span> +<span class="title">R</span>] <span class="keyword">extends</span> <span class="title">AnyRef</span> {</span> self =&gt;
  <span class="javadoc">/** Apply the body of this function to the argument.
   *  <span class="javadoctag">@return</span>   the result of function application.
   */</span>
  <span class="keyword">def</span> apply(v1: T1): R
......
</pre></td></tr></table></figure>

<p>可以看到Function1参数可以是scala.Int,scala.Long,scala.Float,scala.Double，返回值可以是scala.Unit,scala.Boolean,scala.Int,scala.Float,scala.Long,scala.Double 再来看Range.foreach的源码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre>...... 
@inline final override def foreach[<span class="link_label">@specialized(Unit) U</span>](<span class="link_url">f: Int =&gt; U</span>) {
<span class="code">    if (validateRangeBoundaries(f)) {</span>
<span class="code">      var i = start</span>
<span class="code">      val terminal = terminalElement</span>
<span class="code">      val step = this.step</span>
<span class="code">      while (i != terminal) {</span>
<span class="code">        f(i)</span>
<span class="code">        i += step</span>
<span class="code">      }</span>
<span class="code">    }</span>
  }
......
</pre></td></tr></table></figure>

<p>首先此方法是没有返回值的，也就是Unit。而Function1的返回值可以是scala.Unit,scala.Boolean,scala.Int,scala.Float,scala.Long,scala.Double 如果不限定@specialized(Unit),则Function1可能返回其他类型，但是此方法体根本就不返回，即使设置了也无法获得返回值</p>
<p>\10. 添加 assert(n &gt;= 0) 到factorial方法。在启用断言的情况下编译并校验factorial(-1) 会抛异常。在禁用断言的情况下编译。会发生什么？用javap检查该断言调用</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">Test</span> {</span>
  <span class="keyword">def</span> factorial(n: Int): Int = {
    assert(n &gt; <span class="number">0</span>)
    n
  }

  <span class="keyword">def</span> main(args: Array[String]) {
    factorial(-<span class="number">1</span>)
  }
}
</pre></td></tr></table></figure>

<p>编译报错</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>Exception <span class="keyword">in</span> thread <span class="string">"main"</span> java<span class="preprocessor">.lang</span><span class="preprocessor">.AssertionError</span>: assertion failed
        at scala<span class="preprocessor">.Predef</span>$<span class="preprocessor">.assert</span>(Predef<span class="preprocessor">.scala</span>:<span class="number">165</span>)
        at Test$<span class="preprocessor">.factorial</span>(Test<span class="preprocessor">.scala</span>:<span class="number">6</span>)
        at Test$<span class="preprocessor">.main</span>(Test<span class="preprocessor">.scala</span>:<span class="number">11</span>)
        at Test<span class="preprocessor">.main</span>(Test<span class="preprocessor">.scala</span>)
        at sun<span class="preprocessor">.reflect</span><span class="preprocessor">.NativeMethodAccessorImpl</span><span class="preprocessor">.invoke</span>0(Native Method)
        at sun<span class="preprocessor">.reflect</span><span class="preprocessor">.NativeMethodAccessorImpl</span><span class="preprocessor">.invoke</span>(NativeMethodAccessorImpl<span class="preprocessor">.java</span>:<span class="number">39</span>)
        at sun<span class="preprocessor">.reflect</span><span class="preprocessor">.DelegatingMethodAccessorImpl</span><span class="preprocessor">.invoke</span>(DelegatingMethodAccessorImpl<span class="preprocessor">.java</span>:<span class="number">25</span>)
        at java<span class="preprocessor">.lang</span><span class="preprocessor">.reflect</span><span class="preprocessor">.Method</span><span class="preprocessor">.invoke</span>(Method<span class="preprocessor">.java</span>:<span class="number">597</span>)
        at <span class="keyword">com</span><span class="preprocessor">.intellij</span><span class="preprocessor">.rt</span><span class="preprocessor">.execution</span><span class="preprocessor">.application</span><span class="preprocessor">.AppMain</span><span class="preprocessor">.main</span>(AppMain<span class="preprocessor">.java</span>:<span class="number">120</span>)
</pre></td></tr></table></figure>

<p>禁用assert</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="attribute">-Xelide</span><span class="attribute">-below</span> <span class="number">2011</span>
</pre></td></tr></table></figure>

<p>反编译此类javap -c Test$ 得到</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="code">......
public int factorial(int);
  Code:
   0:   getstatic       #19; //Field scala/Predef$.MODULE$:Lscala/Predef$;
   3:   iload_1
   4:   iconst_0
   5:   if_icmple       12
   8:   iconst_1
   9:   goto    13
   12:  iconst_0
   13:  invokevirtual   #23; //Method scala/Predef$.assert:(Z)V
   16:  iload_1
   17:  ireturn
......</span>
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="scala" scheme="http://www.swanlinux.net/tags/scala/"/>
    
      <category term="《快学scala》练习" scheme="http://www.swanlinux.net/categories/%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《快学scala》第十四章 模式匹配和样例类]]></title>
    <link href="http://www.swanlinux.net/2014/10/21/scala_note_14/"/>
    <id>http://www.swanlinux.net/2014/10/21/scala_note_14/</id>
    <published>2014-10-21T11:42:16.000Z</published>
    <updated>2015-05-23T22:03:07.643Z</updated>
    <content type="html"><![CDATA[<p>\1. JDK 发行包有一个src.zip文件包含了JDK的大多数源代码。解压并搜索样例标签（用正则表达式case[^:]+:）。然后查找以//开头并包含[Ff]alls?thr 的注释，捕获类似// Falls through 或 // just fall thru 这样的注释。假定JDK的程序名遵守Java编码习惯，在该写注释的地方写下了这些注释，有多少百分比的样例是会掉入到下一个分支的？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>略
</pre></td></tr></table></figure>

<p>\2. 利用模式匹配，编写一个swap函数，接受一个整数的对偶，返回对偶的两个组成部件互换位置的新对偶。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">swapTest</span> <span class="keyword">extends</span> <span class="title">App</span> {</span>
  <span class="keyword">def</span> swap[T, S](tup: (T, S)) : (S, T) = {
    tup <span class="keyword">match</span> {
      <span class="keyword">case</span> (a, b) =&gt; (b, a)
    }
  }

  println(swap((<span class="number">2</span>, <span class="number">3</span>)))
}
</pre></td></tr></table></figure>

<p>\3. 利用模式匹配，编写一个 swap 函数，交换数组中前两个元素的位置，前提条件是数组长度至少为2</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">swap1Test</span> <span class="keyword">extends</span> <span class="title">App</span> {</span>
  <span class="keyword">def</span> swap(arr: Array[Int]) : Array[Int] = {
    arr <span class="keyword">match</span> {
      <span class="keyword">case</span> Array(a, b, rest @ _*) =&gt; Array(b, a) ++ rest
      <span class="keyword">case</span> _ =&gt; arr
    }
  }

  println(swap(Array(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)).mkString(<span class="string">","</span>))
}
</pre></td></tr></table></figure>

<p>\4. 添加一个样例类 Multiple，作为Item类的子类。举例来说，Multiple(10, Article(“Blackwell Toster”, 29.95)) 描述的是10个烤面包机。当然了，你应该可以在第二个参数的位置接受任何Item, 不论是Bundle还是另一个Multiple。扩展price函数对应对这个新的样例。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span></span>
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Article</span><span class="params">(description: String, price: Double)</span> <span class="keyword">extends</span> <span class="title">Item</span></span>
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Bundle</span><span class="params">(description: String, discount: Double, items: Item*)</span> <span class="keyword">extends</span> <span class="title">Item</span></span>
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Multiple</span><span class="params">(count: Int, item: Item)</span> <span class="keyword">extends</span> <span class="title">Item</span></span>

<span class="class"><span class="keyword">object</span> <span class="title">itemTest</span> <span class="keyword">extends</span> <span class="title">App</span> {</span>
  <span class="keyword">def</span> price(item: Item) : Double = {
    item <span class="keyword">match</span> {
      <span class="keyword">case</span> Article(_, p) =&gt; p
      <span class="keyword">case</span> Bundle(_, disc, its @ _*) =&gt; its.map(price _).sum - disc
      <span class="keyword">case</span> Multiple(count, it) =&gt; count * price(it)
    }                                                         
  }                                                           

  println(price(Multiple(<span class="number">10</span>, Article(<span class="string">"Blackwell Toster"</span>, <span class="number">29.95</span>))))
}
</pre></td></tr></table></figure>

<p>\5. 我们可以用列表制作只在叶子节点存放值的树。举例来说，列表((3 8) 2 (5)) 描述的是如下这样一棵树：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>       *
      /<span class="string">|\</span>
     * <span class="number">2</span> *
    /\   <span class="string">|</span>
   <span class="number">3</span>  <span class="number">8</span>  <span class="number">5</span>
</pre></td></tr></table></figure>

<p>不过，有些列表元素是数字，而另一些是列表。在Scala中，你不能拥有异构的列表，因此你必须使用List[Any]。编写一个leafSum函数，计算所有叶子节点中的元素之和，用模式匹配来区分数字和列表。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">listTest</span> <span class="keyword">extends</span> <span class="title">App</span> {</span>
  <span class="keyword">val</span> list: List[Any] = List(List(<span class="number">3</span>, <span class="number">8</span>), <span class="number">2</span>, List(<span class="number">5</span>))

  <span class="keyword">def</span> leafSum(list: List[Any]) : Int = {
    <span class="keyword">var</span> total = <span class="number">0</span>
    list.foreach(
      item =&gt; item <span class="keyword">match</span> {
        <span class="keyword">case</span> l: List[Any] =&gt; total += leafSum(l)
        <span class="keyword">case</span> l: Int =&gt; total += l
      }
    )

    total
  }

  println(leafSum(list))
}
</pre></td></tr></table></figure>

<p>\6. 制作这样的树更好的做法是使用样例类。我们不妨从二叉树开始。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span></span>
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Leaf</span><span class="params">(value : Int)</span> <span class="keyword">extends</span> <span class="title">BinaryTree</span></span>
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Node</span><span class="params">(left: BinaryTree, right: BinaryTree)</span> <span class="keyword">extends</span> <span class="title">BinaryTree</span></span>
</pre></td></tr></table></figure>

<p>编写一个函数计算所有叶子节点中的元素之和。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span></span>
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Leaf</span><span class="params">(value : Int)</span> <span class="keyword">extends</span> <span class="title">BinaryTree</span></span>
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Node</span><span class="params">(left: BinaryTree, right: BinaryTree)</span> <span class="keyword">extends</span> <span class="title">BinaryTree</span></span>

<span class="class"><span class="keyword">object</span> <span class="title">BinaryTreeTest</span> <span class="keyword">extends</span> <span class="title">App</span> {</span>
  <span class="keyword">val</span> list = Node(Leaf(<span class="number">8</span>), Node(Leaf(<span class="number">3</span>), Leaf(<span class="number">4</span>)))
 
  <span class="keyword">def</span> leafSum(tree: BinaryTree) : Int = {
    <span class="keyword">var</span> total : Int = <span class="number">0</span>
    tree <span class="keyword">match</span> {
      <span class="keyword">case</span> Node(left, right) =&gt; total += leafSum(left) + leafSum(right)
      <span class="keyword">case</span> Leaf(value: Int) =&gt; total += value
    }                         

    total
  }                           

  println(leafSum(list))
}
</pre></td></tr></table></figure>

<p>\7. 扩展前一个练习中的树，使得每个节点可以有任意多得后代，并重新实现 leafSum 函数。第5题中的应该能够通过下述代码表示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="function">Node(<span class="function">Node(<span class="function">Leaf(<span class="number">3</span>)</span>, <span class="function">Leaf(<span class="number">8</span>)</span>)</span>, <span class="function">Leaf(<span class="number">2</span>)</span>, <span class="function">Node(<span class="function">Leaf(<span class="number">5</span>)</span>)</span>)</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Tree</span></span>
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Leaf</span><span class="params">(value : Int)</span> <span class="keyword">extends</span> <span class="title">Tree</span></span>
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Node</span><span class="params">(item: Tree*)</span> <span class="keyword">extends</span> <span class="title">Tree</span></span>

<span class="class"><span class="keyword">object</span> <span class="title">TreeTest</span> <span class="keyword">extends</span> <span class="title">App</span> {</span>
  <span class="keyword">val</span> tree = Node(Node(Leaf(<span class="number">3</span>), Leaf(<span class="number">8</span>)), Leaf(<span class="number">2</span>), Node(Leaf(<span class="number">5</span>)))
  
  <span class="keyword">def</span> leafSum(tree: Tree) : Int = {
    <span class="keyword">var</span> total : Int = <span class="number">0</span>
    tree <span class="keyword">match</span> {
      <span class="keyword">case</span> Node(rest @ _*) =&gt; rest.foreach {
        item =&gt; total += leafSum(item)
      }
      <span class="keyword">case</span> Leaf(value: Int) =&gt; total += value
    } 
    
    total
  } 
  
  println(leafSum(tree))
}
</pre></td></tr></table></figure>

<p>\8. 扩展前一个练习中的树，使得每个非叶子节点除了后代之外，能够存放一个操作符。然后编写一个eval函数来计算它的值。举例来说：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>       + 
      /<span class="string">|\</span>
     * <span class="number">2</span> - 
    /\   <span class="string">|</span>
   <span class="number">3</span>  <span class="number">8</span>  <span class="number">5</span>
</pre></td></tr></table></figure>

<p>上面树的值为(3 x 8) + 2 + (-5) = 21</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span></span>
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Leaf</span><span class="params">(value : Int)</span> <span class="keyword">extends</span> <span class="title">BinaryTree</span></span>
<span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Node</span><span class="params">(root: Char, items: BinaryTree*)</span> <span class="keyword">extends</span> <span class="title">BinaryTree</span></span>

<span class="class"><span class="keyword">object</span> <span class="title">evalTest</span> <span class="keyword">extends</span> <span class="title">App</span> {</span>
  <span class="keyword">def</span> eval(tree: BinaryTree) : Int = {
    tree <span class="keyword">match</span> {
      <span class="keyword">case</span> Leaf(value) =&gt; value
      <span class="keyword">case</span> Node(op: Char, rest @ _*) =&gt; {
        op <span class="keyword">match</span> {
          <span class="keyword">case</span> <span class="string">'+'</span> =&gt; rest.map(eval).sum
          <span class="keyword">case</span> <span class="string">'*'</span> =&gt; rest.map(eval).reduceLeft(_ * _)
          <span class="keyword">case</span> <span class="string">'-'</span> =&gt; rest.map(eval).foldLeft(<span class="number">0</span>)(_ - _)
        }            
      }              
    }                               
  }                      
                         
  <span class="keyword">val</span> tree = Node(<span class="string">'+'</span>, Node(<span class="string">'*'</span>, Leaf(<span class="number">3</span>), Leaf(<span class="number">8</span>)), Leaf(<span class="number">2</span>), Node(<span class="string">'-'</span>, Leaf(<span class="number">5</span>)))
  println(eval(tree))
}
</pre></td></tr></table></figure>

<p>\9. 编写一个函数，计算List[Option[Int]] 中所有非None值之和。不得使用match语句。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">getOrElseTest</span> <span class="keyword">extends</span> <span class="title">App</span> {</span>
  <span class="keyword">val</span> list = List(Option(<span class="number">1</span>), None, Option(<span class="number">2</span>))
  println(list.map(_.getOrElse(<span class="number">0</span>)).sum)
}
</pre></td></tr></table></figure>

<p>\10. 编写一个函数，将两个类型为Double =&gt; Option[Double] 的函数组合在一起，产生另一个同样类型的函数。如果其中一个函数返回None，则组合函数也应返回None。例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">def</span> f(x: Double) = <span class="keyword">if</span> (x &gt; = <span class="number">0</span>) Some(sqrt(x)) <span class="keyword">else</span> None
<span class="keyword">def</span> g(x: Double) = <span class="keyword">if</span> (x != <span class="number">1</span>) Some(<span class="number">1</span> / (x - <span class="number">1</span>)) <span class="keyword">else</span> None
<span class="keyword">val</span> h = compose(f, g)
</pre></td></tr></table></figure>

<p>h(2) 将得到Some(1), 而 h(1) 和 h(0) 将得到 None</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="keyword">import</span> scala.math.sqrt

<span class="class"><span class="keyword">object</span> <span class="title">composeTest</span> <span class="keyword">extends</span> <span class="title">App</span> {</span>
  <span class="keyword">def</span> compose(f: (Double) =&gt; Option[Double], g: (Double) =&gt; Option[Double]) : (Double) =&gt; Option[Double] = {
    (x: Double) =&gt; {
      <span class="keyword">if</span> (f(x) == None || g(x) == None) None <span class="keyword">else</span> g(x)
    }
  } 

  <span class="keyword">def</span> f(x: Double) = <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) Some(sqrt(x)) <span class="keyword">else</span> None
  <span class="keyword">def</span> g(x: Double) = <span class="keyword">if</span> (x != <span class="number">1</span>) Some(<span class="number">1</span> / (x - <span class="number">1</span>)) <span class="keyword">else</span> None
  <span class="keyword">val</span> h = compose(f, g)
  println(h(<span class="number">2</span>))
  println(h(<span class="number">1</span>))
  println(h(<span class="number">0</span>))
}
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="scala" scheme="http://www.swanlinux.net/tags/scala/"/>
    
      <category term="《快学scala》练习" scheme="http://www.swanlinux.net/categories/%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《快学scala》第十三章 集合]]></title>
    <link href="http://www.swanlinux.net/2014/10/19/scala_note_13/"/>
    <id>http://www.swanlinux.net/2014/10/19/scala_note_13/</id>
    <published>2014-10-19T06:42:16.000Z</published>
    <updated>2015-05-23T22:03:07.643Z</updated>
    <content type="html"><![CDATA[<p>\1. 编写一个函数，给定字符串，产出一个包含所有字符的下标的映射。举例来说，indexes(“Mississippi”)应返回一个映射，让’M’对应集{0}，’i’ 对应集{1, 4, 7, 10}，依次类推。使用字符到可变集的映射。另外，你如何保证集是经过排序的？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre><span class="keyword">import</span> scala.collection.mutable.{HashMap, SortedSet}
                                         
<span class="class"><span class="keyword">object</span> <span class="title">indexesTest</span> <span class="keyword">extends</span> <span class="title">App</span> {</span>         
  <span class="keyword">def</span> indexes(str: String) : HashMap[Char, SortedSet[Int]] = {
    <span class="keyword">var</span> i = <span class="number">0</span>
    <span class="keyword">var</span> map = <span class="keyword">new</span> HashMap[Char, SortedSet[Int]]();
    str.foreach{
      item =&gt; {
        map.get(item) <span class="keyword">match</span> {
          <span class="keyword">case</span> Some(result) =&gt; map(item) = result + i
          <span class="keyword">case</span> None =&gt; map += (item -&gt; SortedSet(i))
        }                             
      }                               

      i += <span class="number">1</span>
    }                 

    map
  }

  println(indexes(<span class="string">"Mississippi"</span>))
}
</pre></td></tr></table></figure>

<p>\2. 重复前一个练习，这次用字符列表的不可变映射。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre><span class="keyword">import</span> scala.collection.mutable.ListBuffer
<span class="keyword">import</span> scala.collection.immutable.HashMap

<span class="class"><span class="keyword">object</span> <span class="title">listBufferTest</span> <span class="keyword">extends</span> <span class="title">App</span> {</span>
  <span class="keyword">def</span> indexes(str: String): HashMap[Char, ListBuffer[Int]] = {
    <span class="keyword">var</span> map = <span class="keyword">new</span> HashMap[Char, ListBuffer[Int]]()
    <span class="keyword">var</span> i = <span class="number">0</span>
    str.foreach{
      item =&gt; {
        map.get(item) <span class="keyword">match</span> {
          <span class="keyword">case</span> Some(result) =&gt; result += i
          <span class="keyword">case</span> None =&gt; map += (item -&gt; ListBuffer(i))
        }
      }
      i += <span class="number">1</span>
    }

    map
  }

  println(indexes(<span class="string">"Mississippi"</span>))
}
</pre></td></tr></table></figure>

<p>\3. 编写一个函数，从一个整型链表中去除所有零值。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">listFilterTest</span> <span class="keyword">extends</span> <span class="title">App</span> {</span>
  <span class="keyword">def</span> listFilter(list: List[Int]) : List[Int] = {
    list.filter(_ != <span class="number">0</span>)
  }

  println(listFilter(List(<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">9</span>)))
}
</pre></td></tr></table></figure>

<p>\4. 编写一个函数，接受一个字符串的集合，以及一个从字符串到整数值的映射。举例来说，给定Array(“Tom”, “Fred”, “Harry”) 和 Map(“Tom” -&gt; 3, “Dick” -&gt; 4, “Harry” -&gt; 5), 返回Array(3, 5)。提示：用flatMap将get返回的Option值组合在一起。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">flatMapTest</span> <span class="keyword">extends</span> <span class="title">App</span> {</span>
  <span class="keyword">def</span> find(src: Array[String], map: Map[String, Int]) : Array[Int] = {
    src.flatMap(map.get(_))
  }

  println(find(Array(<span class="string">"Tom"</span>, <span class="string">"Fred"</span>, <span class="string">"Harry"</span>), Map(<span class="string">"Tom"</span> -&gt; <span class="number">3</span>, <span class="string">"Dick"</span> -&gt; <span class="number">4</span>, <span class="string">"Harry"</span> -&gt; <span class="number">5</span>)).mkString(<span class="string">","</span>))
}
</pre></td></tr></table></figure>

<p>\5. 实现一个函数，作用与mkString相同，使用reduceLeft。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">mkStringTest</span> <span class="keyword">extends</span> <span class="title">App</span> {</span>
  <span class="keyword">val</span> test =  <span class="keyword">new</span> scala.collection.mutable.ArrayBuffer[String]() <span class="keyword">with</span> myMkString
  test += <span class="string">"test"</span>
  test += <span class="string">"test111"</span>
  println(test.myMkString)
}        
         
<span class="class"><span class="keyword">trait</span> <span class="title">myMkString</span> {</span>
  <span class="keyword">this</span>: scala.collection.mutable.Iterable[String] =&gt;
  <span class="keyword">def</span> myMkString = <span class="keyword">if</span> (<span class="keyword">this</span> != Nil) <span class="keyword">this</span>.reduceLeft(_ + _)
}
</pre></td></tr></table></figure>

<p>\6. 给定整型列表lst, (lst :\ List<a href="">Int</a>)(_ :: _)得到什么？(List<a href="">Int</a> /: lst)(_ :+ _)又得到什么？如何修改它们中的一个，以对原列表进行反向排列？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre>object listTest extends App {
  val lst = List(1, 2, 3, 4, 5)
  // 从集合尾部开始折叠
  // 新的集合中添加元素到头部
  // 结果：List(1, 2, 3, 4, 5)
  println((lst :\ List[<span class="link_label">Int</span>](<span class="link_url"></span>))(<span class="emphasis">_ :: _</span>)) 

  // 从集合头部开始折叠
  // 新的集合中在尾部追加一个元素
  // 结果： List(1, 2, 3, 4, 5)
  println((List[<span class="link_label">Int</span>](<span class="link_url"></span>) /: lst)(<span class="emphasis">_ :+ _</span>))

  // 反向排序
  println((lst :\ List[<span class="link_label">Int</span>](<span class="link_url"></span>))((a, b) =&gt; b :+ a))

  println((List[<span class="link_label">Int</span>](<span class="link_url"></span>) /: lst)((a, b) =&gt; b :: a))
}
</pre></td></tr></table></figure>

<p>\7. 在13.11 节中，表达式(prices zip quantities) map {p =&gt; p._1 * p._2} 有些不够优雅。我们不能用(prices zip quantities) map (_ <em> _)，因为 _ \</em> _是一个带两个参数的函数，而我们需要的是一个带单个类型为元组为参数的函数。将tupled应用于乘法函数，以便我们可以用它来映射由对偶组成的的列表</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">tupledTest</span> <span class="keyword">extends</span> <span class="title">App</span> {</span>
  <span class="keyword">val</span> prices = List(<span class="number">5.0</span>,<span class="number">20.0</span>,<span class="number">9.95</span>)
  <span class="keyword">val</span> quantities = List(<span class="number">10</span>,<span class="number">2</span>,<span class="number">1</span>)
  println((prices zip quantities) map { Function.tupled(_ * _) })
}
</pre></td></tr></table></figure>

<p>\8. 编写一个函数，将Double数组转化为二维数组。传入列数作为参数。举例来说，Array(1, 2, 3, 4, 5, 6)和三列，返回Array(Array(1, 2, 3), Array(4, 5, 6))。用grouped方法。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">groupedTest</span> <span class="keyword">extends</span> <span class="title">App</span> {</span>
  <span class="keyword">def</span> groupArr(arr: Array[Int]): Array[Array[Int]] = {
    arr.grouped(<span class="number">3</span>).toArray
  }    
  <span class="keyword">val</span> test = Array(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)
  groupArr(test).foreach(item =&gt; {
      println(<span class="string">"========="</span>)
      item.foreach(println)
  })  
}
</pre></td></tr></table></figure>

<p>\9. Harry Hacker 写了一个从命令行接收一系列文件名的程序，对每个文件名，他都启动一个新的线程来读取文件内容并更新一个字母出现频率映射，声明为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>val frequencies = new scala<span class="preprocessor">.collection</span><span class="preprocessor">.mutable</span><span class="preprocessor">.HashMap</span>[Char, Int] with scala<span class="preprocessor">.collection</span><span class="preprocessor">.mutable</span><span class="preprocessor">.SynchronizedMap</span>[Char, Int]
</pre></td></tr></table></figure>

<p>当读到字母c时，他调用</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="function"><span class="title">frequencies</span><span class="params">(c)</span> = <span class="title">frequencies</span>.<span class="title">getOrElse</span><span class="params">(c, <span class="number">0</span>)</span> + 1</span>
</pre></td></tr></table></figure>

<p>为什么这样做得不到正确答案？如果他用如下方式实现呢：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>import scala<span class="preprocessor">.collection</span><span class="preprocessor">.JavaConversions</span><span class="preprocessor">.asScalaConcurrentMap</span>

val frequencies: scala<span class="preprocessor">.collection</span><span class="preprocessor">.mutable</span><span class="preprocessor">.ConcurrentMap</span>[Char, Int] = new java<span class="preprocessor">.util</span><span class="preprocessor">.concurrent</span><span class="preprocessor">.ConcurrentMap</span>[Char, Int]
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>并发问题，并发修改集合不安全.修改后的代码和修改前的代码没有什么太大的区别.
</pre></td></tr></table></figure>

<p>\10. Harry Hacker 把文件读取到的字符串中，然后想对字符串的不同部分用并行集合来并发更新字母出现频率映射。他用了如下代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>val frequencies = new scala<span class="preprocessor">.collection</span><span class="preprocessor">.mutable</span><span class="preprocessor">.HashMap</span>[Char, Int]
for (c &lt;- str<span class="preprocessor">.par</span>) frequencies(c) = frequencies<span class="preprocessor">.getOrElse</span>(c, <span class="number">0</span>) + <span class="number">1</span>
</pre></td></tr></table></figure>

<p>为什么说这个想法很糟糕？要真正地并行化这个计算，他应该怎么做呢？（提示：用aggregate） </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>并行修改共享变量，结果无法估计。
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="keyword">import</span> scala.collection.immutable.HashMap
<span class="class"><span class="keyword">object</span> <span class="title">parTest</span> <span class="keyword">extends</span> <span class="title">App</span> {</span>
  <span class="keyword">val</span> str = <span class="string">"aaabbbcccaaassssccc"</span>
  
  <span class="keyword">val</span> frequencies = str.par.aggregate(HashMap[Char, Int]())(
    (map, item) =&gt; {
      map + (item -&gt; (map.getOrElse(item, <span class="number">0</span>) + <span class="number">1</span>))
    },
    (map1, map2) =&gt; {
      (map1.keySet ++ map2.keySet).foldLeft(HashMap[Char, Int]())(
        (result, k) =&gt; {
          result + (k -&gt; (map1.getOrElse(k, <span class="number">0</span>) + map2.getOrElse(k, <span class="number">0</span>)))
        }  
      ) 
    } 
  ) 
  
  println(frequencies)
}
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="scala" scheme="http://www.swanlinux.net/tags/scala/"/>
    
      <category term="《快学scala》练习" scheme="http://www.swanlinux.net/categories/%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《快学scala》第十二章 高阶函数]]></title>
    <link href="http://www.swanlinux.net/2014/10/18/scala_note_12/"/>
    <id>http://www.swanlinux.net/2014/10/18/scala_note_12/</id>
    <published>2014-10-18T06:42:16.000Z</published>
    <updated>2015-05-23T22:03:07.643Z</updated>
    <content type="html"><![CDATA[<p>\1. 编写函数 values(fun: (Int) => Int, low:Int, high: Int), 该函数输出一个集合，对应给定区间内给定函数的输入和输出。比如，values(x=> x * x, -5, 5)应该产生一个对偶的集合(-5, 25), (-4, 16), (-3, 9), …., (5, 25)。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre>object valueTest extends App {

  def values<span class="function"><span class="params">(func: (Int) =&gt; Int, low: Int, high: Int)</span> = {
    <span class="title">val</span> <span class="title">result</span> = <span class="params">(low to high)</span>.<span class="title">map</span><span class="params">(
      p =&gt; {
        (p, func(p))
      }
    )</span>;

    <span class="title">result</span>
  }

  <span class="title">def</span> <span class="title">func</span><span class="params">(x: Int)</span> = {
    <span class="title">x</span> * <span class="title">x</span>
  }

  <span class="title">values</span><span class="params">(func, <span class="number">1</span>, <span class="number">5</span>)</span>.<span class="title">foreach</span><span class="params">(item =&gt; {
    println(item._1)
    println(item._2)
  })</span>
}</span>
</pre></td></tr></table></figure>

<p>\2. 如何用 reduceLeft 得到数组中最大元素？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">reduceLeftTest</span> <span class="keyword">extends</span> <span class="title">App</span> {</span>
  <span class="keyword">val</span> testData = (<span class="number">1</span> to <span class="number">10</span>).toArray

  println(testData.reduceLeft((num1, num2) =&gt; {
    <span class="keyword">if</span> (num1 &gt; num2) {
      num1
    } <span class="keyword">else</span> {
      num2
    }
  }))
}
</pre></td></tr></table></figure>

<p>\3. 用 to 和 reduceLeft 实现阶乘函数，不得使用循环和递归。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">produceTest</span> <span class="keyword">extends</span> <span class="title">App</span> {</span>
  println((<span class="number">1</span> to <span class="number">10</span>).reduceLeft(_ * _))
}
</pre></td></tr></table></figure>

<p>\4. 前一个实现需要处理一个特殊情况，即 n &lt; 1 的情况。展示如何用foldLeft来避免这个需要。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">produceTest</span> <span class="keyword">extends</span> <span class="title">App</span> {</span>
  println((<span class="number">1</span> to -<span class="number">10</span>).foldLeft(<span class="number">1</span>)(_ * _))
}
</pre></td></tr></table></figure>

<p>\5. 编写函数 largest(fun:(Int) =&gt; Int, inputs: Seq[Int]), 输出在给定输入序列中给定函数的最大值。举例来说，largest(x => 10 * x - x * x, 1 to 10) 应该返回 25，不得使用循环和递归。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">largestTest</span> <span class="keyword">extends</span> <span class="title">App</span> {</span>
  <span class="keyword">def</span> largest(func: (Int) =&gt; Int, inputs: Seq[Int]) = {
    <span class="keyword">val</span> opResult = inputs.map(func(_))
    opResult.max
  }               

  println(largest( x =&gt; <span class="number">10</span> * x - x * x, <span class="number">1</span> to <span class="number">10</span>))
}
</pre></td></tr></table></figure>

<p>\6. 修改前一个函数，返回最大的输出对应的输入。举例来说，largestAt(fun: (Int) => Int, inputs: Seq[Int])应该返回5. 不得使用循环递归</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">largestTest</span> <span class="keyword">extends</span> <span class="title">App</span> {</span>
  <span class="keyword">def</span> largest(func: (Int) =&gt; Int, inputs: Seq[Int]) = {
    <span class="keyword">val</span> opResult = inputs.map(item =&gt; {(item, func(item))})
    <span class="keyword">val</span> max = opResult.reduceLeft((item1, item2) =&gt; {
      <span class="keyword">if</span> (item1._2 &gt; item2._2) {
        item1
      } <span class="keyword">else</span> {
        item2
      }
    })

    max._1
  } 
  
  println(largest( x =&gt; <span class="number">10</span> * x - x * x, <span class="number">1</span> to <span class="number">10</span>))
}
</pre></td></tr></table></figure>

<p>\7. 要得到一个序列的对偶很容易，比如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>    <span class="keyword">val</span> pairs = (i <span class="keyword">to</span> <span class="number">10</span>) zip (<span class="number">11</span> <span class="keyword">to</span> <span class="number">20</span>)
</pre></td></tr></table></figure>

<p>假定你想要对这个序列做某种操作—-比如，给对偶中的值求和。但你不能直接用：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>    <span class="built_in">pairs</span>.map(_ + _)
</pre></td></tr></table></figure>

<p>函数 _ + _ 接收两个 Int 作为参数，而不是(Int, Int)对偶。编写函数 adjustToPair, 该函数接受一个类型为(Int, Int) =&gt; Int, 并返回一个等效的、可以以对偶作为参数的函数。举例来说就是： adjustToPair(_ * _)((6, 7))应得到42.</p>
<p>然后用这个函数通过map计算出各个对偶的元素之和</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>object adjustToPairTest extends App {
  def adjustToPair<span class="function"><span class="params">(fun: (Int, Int) =&gt; Int)(item: (Int, Int))</span> = {
    <span class="title">fun</span><span class="params">(item._1, item._2)</span>
  }

  <span class="title">val</span> <span class="title">pairs</span> = <span class="params">(<span class="number">1</span> to <span class="number">10</span>)</span> <span class="title">zip</span> <span class="params">(<span class="number">11</span> to <span class="number">20</span>)</span>
  <span class="title">pairs</span>.<span class="title">map</span><span class="params">(item =&gt; adjustToPair(_ + _)(item))</span>.<span class="title">foreach</span><span class="params">(println)</span>
}</span>
</pre></td></tr></table></figure>

<p>\8. 在12.8节中，你看到了用于两组字符串数组的corresponds方法。做出一个方法的调用，让它帮我们判断字符串数组里的所有元素的长度是否和某个给定整数数组相对应。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">correspondsTest</span> <span class="keyword">extends</span> <span class="title">App</span> {</span>
  <span class="keyword">val</span> a = Array(<span class="string">"aaaaa"</span>, <span class="string">"bbbbbb"</span>, <span class="string">"ccc"</span>)
  <span class="keyword">val</span> b = Array(<span class="string">"aaa"</span>, <span class="string">"bbb"</span>, <span class="string">"ccc"</span>)
  <span class="keyword">val</span> c = Array(<span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>)

  println(a.corresponds(c)(_.length == _))
  println(b.corresponds(c)(_.length == _))
}
</pre></td></tr></table></figure>

<p>\9. 不使用柯里化实现 corresponds 。 然后尝试从以前一个练习的代码来调用。你遇到什么问题？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>类型推断会有问题
</pre></td></tr></table></figure>

<p>\10. 实现一个 unless 控制抽象，工作机制类似 if， 但条件是反过来的。第一个参数需要是换名调用的参数吗？你需要柯里化吗？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">unlessTest</span> <span class="keyword">extends</span> <span class="title">App</span> {</span>
  <span class="keyword">def</span> unless(condition: =&gt; Boolean)(block: =&gt; Unit) {
    <span class="keyword">if</span> (!condition) {
      block
    }
  }

  <span class="keyword">val</span> n = <span class="number">10</span>;
  unless(n == <span class="number">1</span>) {
    println(n)
  }
}

需要换名和柯里化
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="scala" scheme="http://www.swanlinux.net/tags/scala/"/>
    
      <category term="《快学scala》练习" scheme="http://www.swanlinux.net/categories/%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《快学scala》第十一章 操作符]]></title>
    <link href="http://www.swanlinux.net/2014/10/13/scala_note_11/"/>
    <id>http://www.swanlinux.net/2014/10/13/scala_note_11/</id>
    <published>2014-10-13T06:42:16.000Z</published>
    <updated>2015-05-23T22:03:07.643Z</updated>
    <content type="html"><![CDATA[<p>\1. 根据优先级规则， 3 + 4 -&gt; 5 和 3 -&gt; 4 + 5 是如何被求值的？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>在REPL中执行即可得到结果。都是从左至右执行
</pre></td></tr></table></figure>

<p>\2. BigInt 类有一个pow方法，但没有用操作符字符，Scala类库的设计者为什么没有选用**（像Fortran那样）或者^(像Pascal那样)作为乘方操作符呢？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre>Scala中的操作符就是方法，其优先级是根据首字母来判断的，优先级如下

最高优先级:除以下字符外的操作符字符
 * / % 
 + - 
 : 
 =<span class="ruby"> ! 
</span> &lt; &gt; 
 & 
 ˆ 
 | 
 非操作符
 最低优先级:赋值操作符

 一般乘方的操作符是优于乘法操作的，如果使用**作为乘方的话，那么其优先级则与*相同，而如果使用^的话，则优先级低于*操作。优先级都是有问题的。故没有使用这两种操作符
</pre></td></tr></table></figure>

<p>\3. 实现Fraction类，支持 + - * / 操作，支持约分, 例如将 15 / -6 变成 -5 / 2。除以最大公约数，像这样：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">class</span> Fraction(n : <span class="built_in">Int</span>, d: <span class="built_in">Int</span>) {
  <span class="keyword">private</span> val num : <span class="built_in">Int</span> = <span class="keyword">if</span> (d == <span class="number">0</span>) <span class="number">1</span> <span class="keyword">else</span> n * sign(d) / gcd(n, d);
  <span class="keyword">private</span> val den : <span class="built_in">Int</span> = <span class="keyword">if</span> (d == <span class="number">0</span>) <span class="number">0</span> <span class="keyword">else</span> d * sign(d) / gcd(n, d);

  override def toString = num + <span class="string">"/"</span> + den;

  def sign(a : <span class="built_in">Int</span>) = <span class="keyword">if</span> (a &gt; <span class="number">0</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="keyword">if</span> (a &lt; <span class="number">0</span>) -<span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span>

  def gcd(a: <span class="built_in">Int</span>, b: <span class="built_in">Int</span>) : <span class="built_in">Int</span> = <span class="keyword">if</span> (b == <span class="number">0</span>) a.<span class="built_in">abs</span> <span class="keyword">else</span> gcd(b, a % b)
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="code"><pre><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span><span class="params">(n : Int, d: Int)</span> {</span>
  <span class="keyword">private</span> <span class="keyword">val</span> num : Int = <span class="keyword">if</span> (d == <span class="number">0</span>) <span class="number">1</span> <span class="keyword">else</span> n * sign(d) / gcd(n, d);
  <span class="keyword">private</span> <span class="keyword">val</span> den : Int = <span class="keyword">if</span> (d == <span class="number">0</span>) <span class="number">0</span> <span class="keyword">else</span> d * sign(d) / gcd(n, d);

  <span class="keyword">override</span> <span class="keyword">def</span> toString = num + <span class="string">"/"</span> + den;

  <span class="keyword">def</span> sign(a : Int) = <span class="keyword">if</span> (a &gt; <span class="number">0</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="keyword">if</span> (a &lt; <span class="number">0</span>) -<span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span>

  <span class="keyword">def</span> gcd(a: Int, b: Int) : Int = <span class="keyword">if</span> (b == <span class="number">0</span>) a.abs <span class="keyword">else</span> gcd(b, a % b)

  <span class="keyword">def</span> +(a: Fraction) : Fraction = {
    <span class="keyword">return</span> <span class="keyword">new</span> Fraction(<span class="keyword">this</span>.num * a.den + a.num * <span class="keyword">this</span>.den, <span class="keyword">this</span>.den * a.den);
  } 
  
  <span class="keyword">def</span> -(a: Fraction) : Fraction = {
    <span class="keyword">return</span> <span class="keyword">new</span> Fraction(<span class="keyword">this</span>.num * a.den - a.num * <span class="keyword">this</span>.den, <span class="keyword">this</span>.den * a.den);
  } 
  
  <span class="keyword">def</span> *(a: Fraction) : Fraction = {
    <span class="keyword">return</span> <span class="keyword">new</span> Fraction(<span class="keyword">this</span>.num * a.num , <span class="keyword">this</span>.den * a.den);
  } 
  
  <span class="keyword">def</span> /(a: Fraction) : Fraction = {
    <span class="keyword">return</span> <span class="keyword">new</span> Fraction(<span class="keyword">this</span>.num * a.den , <span class="keyword">this</span>.den * a.num);
  } 
} 

<span class="class"><span class="keyword">object</span> <span class="title">FractionTest</span> <span class="keyword">extends</span> <span class="title">App</span> {</span>
  <span class="keyword">val</span> num1 = <span class="keyword">new</span> Fraction(<span class="number">3</span>, <span class="number">4</span>);
  <span class="keyword">val</span> num2 = <span class="keyword">new</span> Fraction(<span class="number">1</span>, <span class="number">2</span>);
  
  println(num1);
  println(num2);
  println(num1 + num2);
  println(num1 - num2);
  println(num1 * num2);
  println(num1 / num2);
}
</pre></td></tr></table></figure>

<p>\4. 实现一个Money类，加入美元和美分字段。提供 +、-操作符已经比较操作符==和\&lt; 。举例来说，Money(1, 75) + Money(0, 50) == Money(2, 25) 应为true, 你应该同时提供 * 和 / 操作符吗？为什么？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
</pre></td><td class="code"><pre><span class="class"><span class="keyword">class</span> <span class="title">Money</span><span class="params">(private val d: Int, private val c: Int)</span> {</span>
  <span class="keyword">private</span> <span class="keyword">var</span> dollars = d;

  <span class="keyword">private</span> <span class="keyword">val</span> cents = {
    <span class="keyword">if</span> (c &gt;= <span class="number">100</span>) {
      dollars += c / <span class="number">100</span>
      c % <span class="number">100</span>
    } <span class="keyword">else</span> <span class="keyword">if</span> (c &lt; -<span class="number">100</span>) {
      dollars -= c / <span class="number">100</span>
      c % <span class="number">100</span>
    } <span class="keyword">else</span> {
      c
    }
  } 
  
  <span class="keyword">override</span> <span class="keyword">def</span> toString = {
    <span class="string">"("</span> + dollars + <span class="string">","</span> + cents + <span class="string">")"</span>
  } 
  
  <span class="keyword">def</span> +(a: Money) = {
    <span class="keyword">new</span> Money(<span class="keyword">this</span>.dollars + a.dollars, <span class="keyword">this</span>.cents + a.cents);
  } 
  
  <span class="keyword">def</span> -(a: Money) = {
    <span class="keyword">new</span> Money(<span class="keyword">this</span>.dollars - a.dollars, <span class="keyword">this</span>.cents - a.cents);
  } 
  
  <span class="keyword">def</span> ==(a: Money) = {
    (<span class="keyword">this</span>.dollars * <span class="number">100</span> + <span class="keyword">this</span>.cents) == (a.dollars * <span class="number">100</span> + a.cents)
  } 
  
  <span class="keyword">def</span> &lt;(a: Money) = {
    (<span class="keyword">this</span>.dollars * <span class="number">100</span> + <span class="keyword">this</span>.cents) &lt; (a.dollars * <span class="number">100</span> + a.cents)
  } 
}

<span class="class"><span class="keyword">object</span> <span class="title">Money</span> {</span>
  <span class="keyword">def</span> apply(d: Int, c: Int) = <span class="keyword">new</span> Money(d, c);
  
  <span class="keyword">def</span> unapply(o: Money) = {
    Some((o.dollars, o.cents))
  } 
} 

<span class="class"><span class="keyword">object</span> <span class="title">MoneyTest</span> <span class="keyword">extends</span> <span class="title">App</span> {</span>
  <span class="keyword">val</span> c = Money(<span class="number">2</span>, <span class="number">175</span>);
  <span class="keyword">val</span> Money(a: Int, b: Int) = c

  println(a)
  println(Money(<span class="number">1</span>, <span class="number">75</span>) + Money(<span class="number">0</span>, <span class="number">50</span>) == Money(<span class="number">2</span>, <span class="number">25</span>))
}
</pre></td></tr></table></figure>

<p>对于美元操作乘、除是没有意义.</p>
<p>\5. 提供操作符用于构造HTML表格。例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">Table</span>() | <span class="string">"Java"</span> | <span class="string">"Scala"</span> || <span class="string">"Gosling"</span> | <span class="string">"Odersky"</span> || <span class="string">"JVM"</span> | <span class="string">"JVM, .NET"</span>
</pre></td></tr></table></figure>

<p>应产出：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">table</span>&gt;</span><span class="tag">&lt;<span class="title">tr</span>&gt;</span><span class="tag">&lt;<span class="title">td</span>&gt;</span>Java<span class="tag">&lt;/<span class="title">td</span>&gt;</span><span class="tag">&lt;<span class="title">td</span>&gt;</span>Scala<span class="tag">&lt;/<span class="title">td</span>&gt;</span><span class="tag">&lt;/<span class="title">tr</span>&gt;</span><span class="tag">&lt;<span class="title">tr</span>&gt;</span><span class="tag">&lt;<span class="title">td</span>&gt;</span>Gosling<span class="tag">&lt;/<span class="title">td</span>&gt;</span><span class="tag">&lt;<span class="title">td</span>&gt;</span>Odersky<span class="tag">&lt;/<span class="title">td</span>&gt;</span><span class="tag">&lt;/<span class="title">tr</span>&gt;</span><span class="tag">&lt;<span class="title">tr</span>&gt;</span><span class="tag">&lt;<span class="title">td</span>&gt;</span>JVM<span class="tag">&lt;/<span class="title">td</span>&gt;</span><span class="tag">&lt;<span class="title">td</span>&gt;</span>JVM, .NET<span class="tag">&lt;/<span class="title">td</span>&gt;</span><span class="tag">&lt;/<span class="title">tr</span>&gt;</span><span class="tag">&lt;/<span class="title">table</span>&gt;</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td><td class="code"><pre><span class="keyword">import</span> scala.collection.mutable.ArrayBuffer

<span class="class"><span class="keyword">class</span> <span class="title">Table</span></span>
{
  <span class="keyword">private</span> <span class="keyword">val</span> trTags : ArrayBuffer[String] = ArrayBuffer();
  <span class="keyword">private</span> <span class="keyword">val</span> tdTags : ArrayBuffer[String] = ArrayBuffer();

  <span class="keyword">def</span> |(str: String) = {
    tdTags += str
    <span class="keyword">this</span>
  }

  <span class="keyword">def</span> ||(str: String) : Table= {
    trTags += <span class="string">"&lt;tr&gt;&lt;td&gt;"</span> + tdTags.mkString(<span class="string">"&lt;/td&gt;&lt;td&gt;"</span>) + <span class="string">"&lt;/td&gt;&lt;tr&gt;"</span>
    tdTags.clear()     
    tdTags += str
    <span class="keyword">this</span>
  }

  <span class="keyword">override</span> <span class="keyword">def</span> toString = {
    <span class="keyword">if</span> (!tdTags.isEmpty) {
      trTags += <span class="string">"&lt;tr&gt;&lt;td&gt;"</span> + tdTags.mkString(<span class="string">"&lt;/td&gt;&lt;td&gt;"</span>) + <span class="string">"&lt;/td&gt;&lt;tr&gt;"</span>
    } 
    
    <span class="string">"&lt;table&gt;"</span> + trTags.mkString(<span class="string">""</span>)+ <span class="string">"&lt;/table&gt;"</span>
  } 
} 

<span class="class"><span class="keyword">object</span> <span class="title">Table</span> {</span>
  <span class="keyword">def</span> apply() = <span class="keyword">new</span> Table()
} 

<span class="class"><span class="keyword">object</span> <span class="title">TableTest</span> <span class="keyword">extends</span> <span class="title">App</span> {</span>
  <span class="keyword">val</span> str = Table() | <span class="string">"Java"</span> | <span class="string">"Scala"</span> || <span class="string">"Gosling"</span> | <span class="string">"Odersky"</span> || <span class="string">"JVM"</span> | <span class="string">"JVM, .NET"</span>
  println(str)
}
</pre></td></tr></table></figure>

<p>\6. 提供一个ASCIIArt 类，其对象包含类似这样的图形：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre> /\_/\
( ' ' )
(  _  )
 <span class="string">| | |</span>
(__<span class="string">|__)</span>
</pre></td></tr></table></figure>

<p>提供将两个ASCIIArt图形横向或纵向结合的操作符，选用适当优先级的操作符命名。横向结合的实例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre> /<span class="command">\_</span>/<span class="command">\ </span>   -----
( ' ' ) / Hello <span class="command">\
</span>(  _  )&lt;  Scala |
 | | |  <span class="command">\ </span>Coder /
(__|__)   -----
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
</pre></td><td class="code"><pre><span class="keyword">import</span> scala.collection.mutable.ArrayBuffer

<span class="class"><span class="keyword">class</span> <span class="title">ASCIIArt</span><span class="params">(str: String)</span> {</span>
  <span class="keyword">val</span> artMap : ArrayBuffer[String] = <span class="keyword">new</span> ArrayBuffer[String]()
  <span class="keyword">if</span> (str != <span class="keyword">null</span> && !str.trim.eq(<span class="string">""</span>)) {
    str.split(<span class="string">"[\r\n]+"</span>).foreach((line: String) =&gt; {
      <span class="keyword">val</span> tmp = <span class="keyword">new</span> ArrayBuffer[String]();
      artMap += line
    })
  }

  <span class="keyword">def</span> <span class="keyword">this</span>() {
    <span class="keyword">this</span>(<span class="string">""</span>)
  }

  <span class="keyword">def</span> +(other: ASCIIArt) : ASCIIArt = {
    <span class="keyword">val</span> art = <span class="keyword">new</span> ASCIIArt()
    <span class="keyword">val</span> length = <span class="keyword">if</span> (<span class="keyword">this</span>.artMap.length &gt;= other.artMap.length) <span class="keyword">this</span>.artMap.length <span class="keyword">else</span> other.artMap.length
    <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until length) {
      <span class="keyword">val</span> thisCur : String = <span class="keyword">if</span> (<span class="keyword">this</span>.artMap.isDefinedAt(i)) <span class="keyword">this</span>.artMap(i) <span class="keyword">else</span> <span class="string">""</span> 
      <span class="keyword">val</span> otherCur : String = <span class="keyword">if</span> (<span class="keyword">this</span>.artMap.isDefinedAt(i)) other.artMap(i) <span class="keyword">else</span> <span class="string">""</span>  
      art.artMap += thisCur + otherCur
    } 

    art
  }

  <span class="keyword">def</span> *(other: ASCIIArt) : ASCIIArt = {
    <span class="keyword">val</span> art = <span class="keyword">new</span> ASCIIArt()
    art.artMap ++= <span class="keyword">this</span>.artMap
    art.artMap ++= other.artMap
    art
  }    
       
  <span class="keyword">override</span> <span class="keyword">def</span> toString = {
    artMap.mkString(<span class="string">"\n"</span>) 
  }    
} 

<span class="class"><span class="keyword">object</span> <span class="title">ASCIIArt</span> {</span>
  <span class="keyword">def</span> apply(str: String) = <span class="keyword">new</span> ASCIIArt(str)
} 

<span class="class"><span class="keyword">object</span> <span class="title">ASCIIArtTest</span> <span class="keyword">extends</span> <span class="title">App</span> {</span>
  <span class="keyword">val</span> a1 = ASCIIArt(<span class="string">""" /\_/\
                      |( ' ' )
                      |(  -  )
                      | | | | 
                      |(__|__)
                      |"""</span>.stripMargin)
  <span class="keyword">val</span> a2 = ASCIIArt(<span class="string">"""    -----
                      |  / Hello \
                      | &lt;  Scala |
                      |  \ Coder /
                      |    -----
                      |"""</span>.stripMargin)
  println(a1 + a2)
  println(a1 * a2)
}
</pre></td></tr></table></figure>

<p>\7. 实现一个BigSequence 类，将64个bit的序列包在一个Long值中。提供apply和update操作来获取和设置某个位置具体的bit</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="comment">// todo</span>
</pre></td></tr></table></figure>

<p>\8. 提供一个Matrix类—-你可以选择需要的是一个2x2的矩阵，任意大小的正方形矩阵，或是mxn的矩阵。支持+和*操作。*操作应同样适用于单值，例如 mat * 2. 单个元素可以通过 mat(row,col)得到</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
</pre></td><td class="code"><pre><span class="keyword">import</span> scala.collection.mutable.ArrayBuffer
<span class="class"><span class="keyword">class</span> <span class="title">Matrix</span><span class="params">(private val data: Array[Int], private val nrow: Int)</span>{</span>
  <span class="keyword">private</span> <span class="keyword">val</span> matrixData : Array[Array[Int]] = {
    <span class="keyword">val</span> cols = (data.length.toFloat / nrow).ceil.toInt
    <span class="keyword">val</span> result : Array[Array[Int]] = Array.ofDim[Int](nrow, cols);
    <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until nrow) {
      <span class="keyword">for</span> (j &lt;- <span class="number">0</span> until cols) {
        <span class="keyword">val</span> index = i*cols + j
        result(i)(j) = <span class="keyword">if</span> (data.isDefinedAt(index)) data(index) <span class="keyword">else</span> <span class="number">0</span>
      }
    }
    result
  }

  <span class="keyword">override</span> <span class="keyword">def</span> toString = {
    <span class="keyword">var</span> str = <span class="string">""</span>
    matrixData.map((p: Array[Int]) =&gt; {
      p.mkString(<span class="string">","</span>)
    }).mkString(<span class="string">"\n"</span>)
  }

  <span class="keyword">def</span> *(a: Matrix) = {
    <span class="keyword">val</span> data: ArrayBuffer[Int] = ArrayBuffer();
    <span class="keyword">for</span> (i &lt;- <span class="number">0</span> to  a.matrixData.length - <span class="number">1</span>) {
      <span class="keyword">for</span> (j &lt;- <span class="number">0</span> to a.matrixData(<span class="number">0</span>).length - <span class="number">1</span>) {
        data += a.matrixData(i)(j) * <span class="keyword">this</span>.matrixData(i)(j)
      }
    }

    <span class="keyword">new</span> Matrix(data.toArray, a.matrixData.length)
  }

  <span class="keyword">def</span> *(a: Int) = {
    <span class="keyword">val</span> data: ArrayBuffer[Int] = ArrayBuffer();
    <span class="keyword">for</span> (i &lt;- <span class="number">0</span> to  <span class="keyword">this</span>.matrixData.length - <span class="number">1</span>) {
      <span class="keyword">for</span> (j &lt;- <span class="number">0</span> to <span class="keyword">this</span>.matrixData(<span class="number">0</span>).length - <span class="number">1</span>) {
        data += <span class="keyword">this</span>.matrixData(i)(j) * a 
      }
    }

    <span class="keyword">new</span> Matrix(data.toArray, <span class="keyword">this</span>.matrixData.length)
  }

  <span class="keyword">def</span> +(a: Matrix) = {
    <span class="keyword">val</span> data: ArrayBuffer[Int] = ArrayBuffer();
    <span class="keyword">for</span> (i &lt;- <span class="number">0</span> to  <span class="keyword">this</span>.matrixData.length - <span class="number">1</span>) {
      <span class="keyword">for</span> (j &lt;- <span class="number">0</span> to <span class="keyword">this</span>.matrixData(<span class="number">0</span>).length - <span class="number">1</span>) {
        data += <span class="keyword">this</span>.matrixData(i)(j) + a.matrixData(i)(j)
      }
    }

    <span class="keyword">new</span> Matrix(data.toArray, <span class="keyword">this</span>.matrixData.length)
  }

  <span class="keyword">def</span> mat(row: Int, col: Int) = {
    matrixData(row - <span class="number">1</span>)(col - <span class="number">1</span>)
  }
}

<span class="class"><span class="keyword">object</span> <span class="title">MatrixTest</span> <span class="keyword">extends</span> <span class="title">App</span> {</span>
  <span class="keyword">val</span> m = <span class="keyword">new</span> Matrix(Array(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>), <span class="number">3</span>)
  <span class="keyword">val</span> n = <span class="keyword">new</span> Matrix(Array(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>), <span class="number">3</span>)
  println(m * n)
  println(m + n)
  println(m.mat(<span class="number">2</span>, <span class="number">2</span>))
  println(n * <span class="number">10</span>)
}
</pre></td></tr></table></figure>

<p>\9. 为RichFile 类定义unapply操作，提取文件路劲、名称和扩展名。举例来说，文件/home/cay/readme.txt的路劲为/home/cay, 名称为 readme, 扩展名txt</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="keyword">import</span> java.io.File
<span class="class"><span class="keyword">object</span> <span class="title">RichFile</span> {</span> 

  <span class="keyword">def</span> unapply(filePath : String) = {
    <span class="keyword">val</span> file = <span class="keyword">new</span> File(filePath)
    <span class="keyword">val</span> ext = file.getName.split(<span class="string">"\\."</span>)
    Some((file.getParent, file.getName, ext(<span class="number">1</span>)))
  }                                    
}                                      

<span class="class"><span class="keyword">object</span> <span class="title">RichFileTest</span> <span class="keyword">extends</span> <span class="title">App</span> {</span>
  <span class="keyword">val</span> RichFile(path, fileName, ext) = <span class="string">"/home/cay/readme.txt"</span>
  println(path)
  println(fileName)
  println(ext)
}
</pre></td></tr></table></figure>

<p>\10. 为RichFile 类定义一个unapplySeq, 提取所有路阶段。举例来说，对于/home/cay/readme.txt,你应该产出三个路劲的序列: home，cay,readme.txt</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">RichFile</span> {</span>
  <span class="keyword">def</span> unapplySeq(filePath : String) : Option[Seq[String]]= {
    Some(filePath.trim.split(<span class="string">"\\/"</span>))
  } 
} 

<span class="class"><span class="keyword">object</span> <span class="title">RichFileTest</span> <span class="keyword">extends</span> <span class="title">App</span> {</span>
  <span class="keyword">val</span> str = <span class="string">"/home/cay/readme.txt"</span>
  str <span class="keyword">match</span> {
    <span class="keyword">case</span> RichFile(str0, str1, str2, str3) =&gt; {
      println(str1);
      println(str2);
    } 
    <span class="keyword">case</span> _ =&gt; {println(str)}
  } 
}
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="scala" scheme="http://www.swanlinux.net/tags/scala/"/>
    
      <category term="《快学scala》练习" scheme="http://www.swanlinux.net/categories/%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hadoop 2.x 集群安装]]></title>
    <link href="http://www.swanlinux.net/2014/09/14/hadoop_install/"/>
    <id>http://www.swanlinux.net/2014/09/14/hadoop_install/</id>
    <published>2014-09-14T05:02:16.000Z</published>
    <updated>2015-05-23T22:03:07.641Z</updated>
    <content type="html"><![CDATA[<h3 id="安装介绍">安装介绍</h3>
<p>该集群安装6台机器，利用 DNS 服务做主机名解析， NFS 做免密码共享</p>
<p>机器部署情况：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>    <span class="title">h1</span> <span class="number">192.168.1.112</span>  (安装DNS服务器，NFS服务器， Hadoop)
    h2 <span class="number">192.168.1.113</span> 
    h3 <span class="number">192.168.1.114</span>
    h4 <span class="number">192.168.1.115</span>
    h5 <span class="number">192.168.1.116</span>
    h6 <span class="number">192.168.1.117</span>
</pre></td></tr></table></figure>

<h3 id="安装前环境配置">安装前环境配置</h3>
<h4 id="DNS_服务器配置">DNS 服务器配置</h4>
<p>具体安装过程参考 : <a href="http://www.swanlinux.net/2013/02/12/linux_dns/">Linux系统配置DNS主从及缓存服务器</a> 这里只介绍配置过程</p>
<ul>
<li>修改 /etc/named.conf</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre>options {
    <span class="comment">// 将 127.0.0.1 修改为 any</span>
    listen-on port <span class="number">53</span> { any; };
    listen-on-v6 port <span class="number">53</span> { ::<span class="number">1</span>; };
    directory   <span class="string">"/var/named"</span>;
    dump-<span class="keyword">file</span>   <span class="string">"/var/named/data/cache_dump.db"</span>;
        statistics-<span class="keyword">file</span> <span class="string">"/var/named/data/named_stats.txt"</span>;
        memstatistics-<span class="keyword">file</span> <span class="string">"/var/named/data/named_mem_stats.txt"</span>;
    <span class="comment">// 将 127.0.0.1 修改为 any</span>
    allow-query     { any; };
    recursion yes;

    dnssec-enable yes;
    dnssec-validation yes;
    dnssec-lookaside auto;

    <span class="comment">/* Path to ISC DLV key */</span>
    bindkeys-<span class="keyword">file</span> <span class="string">"/etc/named.iscdlv.key"</span>;

    managed-keys-directory <span class="string">"/var/named/dynamic"</span>;
};
</pre></td></tr></table></figure>

<ul>
<li>修改 /etc/named.rfc1912.zones 文件</li>
</ul>
<p>在文件下面添加 正向解析和反向解析的配置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>zone <span class="string">"hadoop.com"</span>{
        <span class="keyword">type</span> master;
        file <span class="string">"hadoop.com.z"</span>;
        allow<span class="attribute">-update</span> { <span class="literal">none</span>; };
};

zone <span class="string">"1.168.192.in-addr.arpa"</span>{
        <span class="keyword">type</span> master;
        file <span class="string">"hadoop.com.f"</span>;
        allow<span class="attribute">-update</span> { <span class="literal">none</span>; };
};
</pre></td></tr></table></figure>

<ul>
<li>配置域名正向解析配置文件</li>
</ul>
<p>配置文件 /var/named/chroot/var/named/hadoop.com.z</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>$TTL <span class="number">1</span>D
@   <span class="keyword">IN</span> SOA  h1<span class="preprocessor">.hadoop</span><span class="preprocessor">.com</span>. grid<span class="preprocessor">.h</span>1<span class="preprocessor">.hadoop</span><span class="preprocessor">.com</span>. (
                    <span class="number">0</span>   <span class="comment">; serial</span>
                    <span class="number">1</span>D  <span class="comment">; refresh</span>
                    <span class="number">1</span>H  <span class="comment">; retry</span>
                    <span class="number">1</span>W  <span class="comment">; expire</span>
                    <span class="number">3</span>H )    <span class="comment">; minimum</span>
@   <span class="keyword">IN</span>  NS  h1<span class="preprocessor">.hadoop</span><span class="preprocessor">.com</span>.
h1<span class="preprocessor">.hadoop</span><span class="preprocessor">.com</span>.  <span class="keyword">IN</span>  A   <span class="number">192.168</span><span class="number">.1</span><span class="number">.112</span>
h2<span class="preprocessor">.hadoop</span><span class="preprocessor">.com</span>.  <span class="keyword">IN</span>  A   <span class="number">192.168</span><span class="number">.1</span><span class="number">.113</span>
h3<span class="preprocessor">.hadoop</span><span class="preprocessor">.com</span>.  <span class="keyword">IN</span>  A   <span class="number">192.168</span><span class="number">.1</span><span class="number">.114</span>
h4<span class="preprocessor">.hadoop</span><span class="preprocessor">.com</span>.  <span class="keyword">IN</span>  A   <span class="number">192.168</span><span class="number">.1</span><span class="number">.115</span>
h5<span class="preprocessor">.hadoop</span><span class="preprocessor">.com</span>.  <span class="keyword">IN</span>  A   <span class="number">192.168</span><span class="number">.1</span><span class="number">.116</span>
h6<span class="preprocessor">.hadoop</span><span class="preprocessor">.com</span>.  <span class="keyword">IN</span>  A   <span class="number">192.168</span><span class="number">.1</span><span class="number">.117</span>
</pre></td></tr></table></figure>

<ul>
<li>配置域名反向解析配置文件</li>
</ul>
<p>配置文件 /var/named/chroot/var/named/hadoop.com.f</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>$TTL <span class="number">1</span>D
@   <span class="keyword">IN</span> SOA  h1<span class="preprocessor">.hadoop</span><span class="preprocessor">.com</span>. grid<span class="preprocessor">.h</span>1<span class="preprocessor">.hadoop</span><span class="preprocessor">.com</span>. (
                    <span class="number">0</span>   <span class="comment">; serial</span>
                    <span class="number">1</span>D  <span class="comment">; refresh</span>
                    <span class="number">1</span>H  <span class="comment">; retry</span>
                    <span class="number">1</span>W  <span class="comment">; expire</span>
                    <span class="number">3</span>H )    <span class="comment">; minimum</span>
@   <span class="keyword">IN</span>  NS  h1<span class="preprocessor">.hadoop</span><span class="preprocessor">.com</span>.
<span class="number">112</span>   <span class="keyword">IN</span>  PTR h1<span class="preprocessor">.hadoop</span><span class="preprocessor">.com</span>.
<span class="number">113</span>   <span class="keyword">IN</span>  PTR h2<span class="preprocessor">.hadoop</span><span class="preprocessor">.com</span>.
<span class="number">114</span>   <span class="keyword">IN</span>  PTR h3<span class="preprocessor">.hadoop</span><span class="preprocessor">.com</span>.
<span class="number">115</span>   <span class="keyword">IN</span>  PTR h4<span class="preprocessor">.hadoop</span><span class="preprocessor">.com</span>.
<span class="number">116</span>   <span class="keyword">IN</span>  PTR h5<span class="preprocessor">.hadoop</span><span class="preprocessor">.com</span>.
<span class="number">117</span>   <span class="keyword">IN</span>  PTR h6<span class="preprocessor">.hadoop</span><span class="preprocessor">.com</span>.
</pre></td></tr></table></figure>

<ul>
<li>修改好重启 named 服务</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>service named restart
chkconfig <span class="comment">--add named</span>
chkconfig named <span class="command"><span class="keyword">on</span></span>
</pre></td></tr></table></figure>

<ul>
<li>测试 DNS 服务</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>[root@h1 ~]<span class="preprocessor"># nslookup </span>
&gt; h1<span class="preprocessor">.hadoop</span><span class="preprocessor">.com</span>
<span class="label">Server:</span>     <span class="number">192.168</span><span class="number">.1</span><span class="number">.112</span>
<span class="label">Address:</span>    <span class="number">192.168</span><span class="number">.1</span><span class="number">.112</span><span class="preprocessor">#53</span>
</pre></td></tr></table></figure>

<h4 id="NFS_配置及免密码配置">NFS 配置及免密码配置</h4>
<ul>
<li>NFS 安装</li>
</ul>
<p>由于系统是 Centos 6.5 和 5.x 的区别是 portmap 在 6.x 中对应的是 rpcbind ，在安装 NFS 中需要安装 rpcbind, 在挂在 nfs服务的节点中需要安装 nfs-utils , rpcbind</p>
<p>除此之外参考 <a href="http://www.swanlinux.net/2013/02/12/linux_nfs/">Linux 系统中文件共享之 NFS</a></p>
<ul>
<li>NFS 共享目录配置</li>
</ul>
<p>将 /data 目录作为共享目录</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="title">vim</span> /etc/exports

添加
/<span class="typedef"><span class="keyword">data</span> *<span class="container">(<span class="title">sync</span>,<span class="title">rw</span>,<span class="title">no_root_squash</span>)</span></span>
</pre></td></tr></table></figure>

<ul>
<li>NFS 目录挂载</li>
</ul>
<p>所有的客户端节点将统一挂载到 /home/nmred/nfs_share/ 目录</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="title">mount</span> -t nfs h1.hadoop.com:/<span class="typedef"><span class="keyword">data</span> /home/nmred/nfs_share/</span>
</pre></td></tr></table></figure>

<p>修改 /etc/fstab</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>添加 (让服务器重启时自动挂载)
<span class="title">h1</span>.hadoop.com:/<span class="typedef"><span class="keyword">data</span>     /home/nmred/nfs_share   nfs     defaults        1 1</span>
</pre></td></tr></table></figure>

<ul>
<li>免密码配置</li>
</ul>
<p><strong>注意：</strong> Hadoop 必须在运行用户可以免密码 ssh 登陆节点机器时才可以正常运行，所以需要对集群 nmred 用户需要做免密码登陆处理</p>
<p>生成公钥：利用 ssh-keygen 生成</p>
<p>将所有节点的 公钥写入到 /home/nmred/nfs_share/authorized_keys 文件中共享</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>[root<span class="variable">@h2</span> ~]<span class="comment"># cat ~/.ssh/id_rsa.pub </span>
ssh-rsa <span class="constant">AAAAB3NzaC1yc2EAAAABIwAAAQEA37St4CEP7G5ghLF0oschDvwoa9A</span>/t3Wa8ssK7xFKUTTkNsELRtvd/<span class="constant">RxwkMjFQB54hJPTFSU12gN3VzybeHD</span>+<span class="constant">SRx4a77sIqH8O37plYWgQWia7ud7NdfF5SmLZJLja</span>+v19ULTvw6czTB6q0Hi9DT26t9YPqFhRMezokrhZ/<span class="number">3</span>QHbsRFWUq2yGYpdvOf3LwJlsI9K5RkLbOQxz6akIl8sZHBQ4zzyLMHq0jpl7EQn/<span class="constant">NQlRUbM8ozVjQlZH</span>+<span class="constant">BBcYSHwuoCwSkLVqdUZucNNePWhD04TDbMIr</span>/wKyOkCd90C1J1W0sirk/<span class="number">3</span>TY/d72jJszGbrmZl89A5zNka2VkvbSCrF7sw== root<span class="variable">@hadoop02</span>
[root<span class="variable">@h2</span> ~]<span class="comment">#</span>
</pre></td></tr></table></figure>

<p>将所有节点的做软连接</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>ln <span class="operator">-s</span> /home/nmred/nfs_share/authorized_keys /home/nmred/.ssh/authorized_keys
</pre></td></tr></table></figure>

<p><strong>注意</strong> 对于.ssh目录，公钥、私钥的权限都有严格的要求</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="bullet">1. </span>用户目录755或700，不能使77*
<span class="bullet">2. </span>.ssh目录755
<span class="bullet">3. </span>.pub或authorized_key 644
<span class="bullet">4. </span>私钥600
</pre></td></tr></table></figure>

<p>这块如果权限不对免密码登陆不会成功</p>
<h4 id="编译hadoop2-x_包">编译hadoop2.x 包</h4>
<ul>
<li>需要用yum 安装用到或依赖的软件包</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>yum <span class="attribute">-y</span> install svn autoconf automake libtool cmake ncurses<span class="attribute">-devel</span> openssl<span class="attribute">-devel</span> gcc<span class="subst">*</span>
</pre></td></tr></table></figure>

<ul>
<li>安装maven， java-jdk</li>
</ul>
<p>下载maven , jdk, bin类型的tar包直接解压到 /usr/local 下,然后设置环境变量如下图：</p>
<p><img src="/image/hadoop/hadoop-001-001.png" alt="环境设置"></p>
<ul>
<li>编译安装protobuf</li>
</ul>
<p><img src="/image/hadoop/hadoop-001-002.png" alt="编译protobuf"></p>
<ul>
<li>在nmred普通用户下克隆hadoop 2.30 源代码，并且执行</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>mvnpackage <span class="attribute">-Pdist</span>,native<span class="attribute">-DskipTests</span>–Dtar
</pre></td></tr></table></figure>

<p>最终编译完成或有一个这样的提示：</p>
<p><img src="/image/hadoop/hadoop-001-003.png" alt="编译成功"></p>
<p>在代码目录下有一个</p>
<p><img src="/image/hadoop/hadoop-001-004.png" alt="hadoop target 目录"></p>
<p>就是编译好的hadoop 安装包，到此就x64位系统的安装包已经制作完成。</p>
<h4 id="Hadoop_部署">Hadoop 部署</h4>
<p>将打包好的hadoop安装包和 JDK 解压到 /home/nmred/distRunDir</p>
<ul>
<li>Hadoop 配置</li>
</ul>
<p>修改hadoop-env.sh </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>export <span class="constant">JAVA_HOME</span>=<span class="regexp">/home/nmred</span><span class="regexp">/distRunDir/jdk</span>1.<span class="number">7.0_55</span>/
</pre></td></tr></table></figure>

<p>修改core-site.xml </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">configuration</span>&gt;</span>
    <span class="tag">&lt;<span class="title">property</span>&gt;</span>
            <span class="tag">&lt;<span class="title">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
            <span class="tag">&lt;<span class="title">value</span>&gt;</span>hdfs://h1.hadoop.com:9000<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">property</span>&gt;</span>
            <span class="tag">&lt;<span class="title">name</span>&gt;</span>io.file.buffer.size<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
            <span class="tag">&lt;<span class="title">value</span>&gt;</span>131072<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">property</span>&gt;</span>
            <span class="tag">&lt;<span class="title">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
            <span class="tag">&lt;<span class="title">value</span>&gt;</span>file:/home/nmred/distRunDir/hadoop-2.3.0/tmp<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
            <span class="tag">&lt;<span class="title">description</span>&gt;</span>Abase for other temporary directories.<span class="tag">&lt;/<span class="title">description</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">property</span>&gt;</span>
            <span class="tag">&lt;<span class="title">name</span>&gt;</span>hadoop.proxyuser.hduser.hosts<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
            <span class="tag">&lt;<span class="title">value</span>&gt;</span>*<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">property</span>&gt;</span>
            <span class="tag">&lt;<span class="title">name</span>&gt;</span>hadoop.proxyuser.hduser.groups<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
            <span class="tag">&lt;<span class="title">value</span>&gt;</span>*<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">configuration</span>&gt;</span>
</pre></td></tr></table></figure>

<p>修改hdfs-site.xml</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">configuration</span>&gt;</span>
    <span class="tag">&lt;<span class="title">property</span>&gt;</span>
            <span class="tag">&lt;<span class="title">name</span>&gt;</span>dfs.namenode.secondary.http-address<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
            <span class="tag">&lt;<span class="title">value</span>&gt;</span>h1.hadoop.com:9001<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">property</span>&gt;</span>
            <span class="tag">&lt;<span class="title">name</span>&gt;</span>dfs.namenode.name.dir<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
            <span class="tag">&lt;<span class="title">value</span>&gt;</span>file:/home/nmred/distRunDir/hadoop-2.3.0/name<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">property</span>&gt;</span>
            <span class="tag">&lt;<span class="title">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
            <span class="tag">&lt;<span class="title">value</span>&gt;</span>file:/home/nmred/distRunDir/hadoop-2.3.0/data<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">property</span>&gt;</span>
            <span class="tag">&lt;<span class="title">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
            <span class="tag">&lt;<span class="title">value</span>&gt;</span>1<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">property</span>&gt;</span>
            <span class="tag">&lt;<span class="title">name</span>&gt;</span>dfs.webhdfs.enabled<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
            <span class="tag">&lt;<span class="title">value</span>&gt;</span>true<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">configuration</span>&gt;</span>
</pre></td></tr></table></figure>

<p>修改 mapred-site.xml</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">configuration</span>&gt;</span>
    <span class="tag">&lt;<span class="title">property</span>&gt;</span>
            <span class="tag">&lt;<span class="title">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
            <span class="tag">&lt;<span class="title">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">property</span>&gt;</span>
            <span class="tag">&lt;<span class="title">name</span>&gt;</span>mapreduce.jobhistory.address<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
            <span class="tag">&lt;<span class="title">value</span>&gt;</span>h1.hadoop.com:10020<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">property</span>&gt;</span>
            <span class="tag">&lt;<span class="title">name</span>&gt;</span>mapreduce.jobhistory.webapp.address<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
            <span class="tag">&lt;<span class="title">value</span>&gt;</span>h1.hadoop.com:19888<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">configuration</span>&gt;</span>
</pre></td></tr></table></figure>

<p>修改 yarn-site.xml </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">configuration</span>&gt;</span>

<span class="comment">&lt;!-- Site specific YARN configuration properties --&gt;</span>
    <span class="tag">&lt;<span class="title">property</span>&gt;</span>
            <span class="tag">&lt;<span class="title">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
            <span class="tag">&lt;<span class="title">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">property</span>&gt;</span>
            <span class="tag">&lt;<span class="title">name</span>&gt;</span>yarn.nodemanager.aux-services.mapreduce.shuffle.class<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
            <span class="tag">&lt;<span class="title">value</span>&gt;</span>org.apache.hadoop.mapred.ShuffleHandler<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">property</span>&gt;</span>
            <span class="tag">&lt;<span class="title">name</span>&gt;</span>yarn.resourcemanager.address<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
            <span class="tag">&lt;<span class="title">value</span>&gt;</span>h1.hadoop.com:8032<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">property</span>&gt;</span>
            <span class="tag">&lt;<span class="title">name</span>&gt;</span>yarn.resourcemanager.scheduler.address<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
            <span class="tag">&lt;<span class="title">value</span>&gt;</span>h1.hadoop.com:8030<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">property</span>&gt;</span>
            <span class="tag">&lt;<span class="title">name</span>&gt;</span>yarn.resourcemanager.resource-tracker.address<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
            <span class="tag">&lt;<span class="title">value</span>&gt;</span>h1.hadoop.com:8031<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">property</span>&gt;</span>
            <span class="tag">&lt;<span class="title">name</span>&gt;</span>yarn.resourcemanager.admin.address<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
            <span class="tag">&lt;<span class="title">value</span>&gt;</span>h1.hadoop.com:8033<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
    <span class="tag">&lt;<span class="title">property</span>&gt;</span>
            <span class="tag">&lt;<span class="title">name</span>&gt;</span>yarn.resourcemanager.webapp.address<span class="tag">&lt;/<span class="title">name</span>&gt;</span>
            <span class="tag">&lt;<span class="title">value</span>&gt;</span>h1.hadoop.com:8088<span class="tag">&lt;/<span class="title">value</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
<span class="tag">&lt;/<span class="title">configuration</span>&gt;</span>
</pre></td></tr></table></figure>

<p>修改 slaves</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>h2<span class="preprocessor">.hadoop</span><span class="preprocessor">.com</span>
h3<span class="preprocessor">.hadoop</span><span class="preprocessor">.com</span>
h4<span class="preprocessor">.hadoop</span><span class="preprocessor">.com</span>
h5<span class="preprocessor">.hadoop</span><span class="preprocessor">.com</span>
h6<span class="preprocessor">.hadoop</span><span class="preprocessor">.com</span>
</pre></td></tr></table></figure>

<ul>
<li>发布脚本</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>
<span class="shebang">#!/bin/bash
</span>
cat /home/nmred/distRunDir/hadoop-<span class="number">2.3</span>.<span class="number">0</span>/etc/hadoop/slaves | awk <span class="string">'{print "scp -rp /home/nmred/distRunDir/ nmred@"$1":/home/nmred/distRunDir/"}'</span> &gt; publish.sh

chmod <span class="number">755</span> publish.sh

./publish.sh
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="hadoop" scheme="http://www.swanlinux.net/tags/hadoop/"/>
    
      <category term="Hadoop" scheme="http://www.swanlinux.net/categories/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《快学scala》第十章 特质]]></title>
    <link href="http://www.swanlinux.net/2014/09/11/scala_note_10/"/>
    <id>http://www.swanlinux.net/2014/09/11/scala_note_10/</id>
    <published>2014-09-11T06:42:16.000Z</published>
    <updated>2015-05-23T22:03:07.642Z</updated>
    <content type="html"><![CDATA[<p>\1. java.awt.Rectangle类有两个很有用的方法translate和grow,但可惜的是像java.awt.geom.Ellipse2D这样的类没有。在Scala中，你可以解决掉这个问题。定义一个RenctangleLike特质,加入具体的translate和grow方法。提供任何你需要用来实现的抽象方法,以便你可以像如下代码这样混入该特质:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>val egg = new java<span class="preprocessor">.awt</span><span class="preprocessor">.geom</span><span class="preprocessor">.Ellipse</span>2D<span class="preprocessor">.Double</span>(<span class="number">5</span>,<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>) with RectangleLike
egg<span class="preprocessor">.translate</span>(<span class="number">10</span>,-<span class="number">10</span>)
egg<span class="preprocessor">.grow</span>(<span class="number">10</span>,<span class="number">20</span>)
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre><span class="keyword">import</span> java.awt.geom.Ellipse2D

<span class="class"><span class="keyword">trait</span> <span class="title">RectangleLike</span> {</span>
  <span class="keyword">this</span>: Ellipse2D.Double =&gt;
  <span class="keyword">def</span> translate(x: Double, y: Double) {
    <span class="keyword">this</span>.x = x
    <span class="keyword">this</span>.y = y
  } 

  <span class="keyword">def</span> grow(x: Double, y: Double) {
    <span class="keyword">this</span>.x += x
    <span class="keyword">this</span>.y += y
  }
}

<span class="class"><span class="keyword">object</span> <span class="title">EclipseTest</span> <span class="keyword">extends</span> <span class="title">App</span> {</span>
  <span class="keyword">val</span> egg = <span class="keyword">new</span> java.awt.geom.Ellipse2D.Double(<span class="number">5</span>,<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>) <span class="keyword">with</span> RectangleLike
  egg.translate(<span class="number">10</span>,-<span class="number">10</span>)
  egg.grow(<span class="number">10</span>,<span class="number">20</span>)
  println(egg.getX)
  println(egg.getY)
}
</pre></td></tr></table></figure>

<p>\2.  通过把scala.math.Ordered[Point]混入java.awt.Point的方式，定义OrderedPoint类。按辞典编辑方式排序，也就是说，如果x\&lt;x’或者x=x’且y\&lt;y’则(x,y)\&lt;(x’,y’) </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="class"><span class="keyword">class</span> <span class="title">OrderedPoint</span><span class="params">(x : Int, y : Int)</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">awt</span>.<span class="title">Point</span><span class="params">(x, y)</span> <span class="keyword">with</span> <span class="title">scala</span>.<span class="title">math</span>.<span class="title">Ordered</span>[<span class="title">OrderedPoint</span>]</span>
{
  <span class="keyword">def</span> compare(that : OrderedPoint) : Int = {
    <span class="keyword">if</span> (<span class="keyword">this</span>.x == that.x && <span class="keyword">this</span>.y == that.y) {
      <span class="number">0</span>
    } <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">this</span>.x &lt; that.x || <span class="keyword">this</span>.x == that.x) && <span class="keyword">this</span>.y &lt; that.y) {
      -<span class="number">1</span>
    } <span class="keyword">else</span> {
      <span class="number">1</span>
    }
  }
}

<span class="class"><span class="keyword">object</span> <span class="title">TestTrait</span> <span class="keyword">extends</span> <span class="title">App</span></span>
{
  <span class="keyword">val</span> test = Array(<span class="keyword">new</span> OrderedPoint(<span class="number">3</span>, <span class="number">4</span>), <span class="keyword">new</span> OrderedPoint(<span class="number">4</span>, <span class="number">5</span>));
  scala.util.Sorting.quickSort(test)
  test.foreach((p : OrderedPoint) =&gt; {println(p)})
  <span class="keyword">val</span> p1 = <span class="keyword">new</span> OrderedPoint(<span class="number">3</span>, <span class="number">4</span>);
  <span class="keyword">val</span> p2 = <span class="keyword">new</span> OrderedPoint(<span class="number">4</span>, <span class="number">5</span>);

  println(p2 &gt; p1)

}
</pre></td></tr></table></figure>

<p>\3.  查看BitSet类,将它的所有超类和特质绘制成一张图。忽略类型参数([…]中的所有内容)。然后给出该特质的线性化规格说明</p>
<p>略 </p>
<p>\4. 提供一个CryptoLogger类，将日志消息以凯撒密码加密。缺省情况下密匙为3，不过使用者也可以重写它。提供缺省密匙和-3作为密匙是的使用示例</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="class"><span class="keyword">trait</span> <span class="title">Logger</span> {</span>
  <span class="keyword">def</span> log(str: String, key: Int = <span class="number">3</span>) : String
}

<span class="class"><span class="keyword">class</span> <span class="title">CryptoLogger</span> <span class="keyword">extends</span> <span class="title">Logger</span> {</span>
  <span class="keyword">def</span> log(str: String, key: Int) : String = {
    <span class="keyword">for</span> ( i &lt;- str) <span class="keyword">yield</span> <span class="keyword">if</span> (key &gt;= <span class="number">0</span>) (<span class="number">97</span> + ((i - <span class="number">97</span> + key)%<span class="number">26</span>)).toChar <span class="keyword">else</span> (<span class="number">97</span> + ((i - <span class="number">97</span> + <span class="number">26</span> + key)%<span class="number">26</span>)).toChar
  }
}    

<span class="class"><span class="keyword">object</span> <span class="title">CryptoLoggerTest</span> <span class="keyword">extends</span> <span class="title">App</span> {</span>
  <span class="keyword">val</span> text = <span class="string">"nmred"</span>
  println(text)
  println(<span class="keyword">new</span> CryptoLogger().log(text))
  println(<span class="keyword">new</span> CryptoLogger().log(text, -<span class="number">3</span>))
}
</pre></td></tr></table></figure>

<p>\5. JavaBean规范里有一种提法叫做属性变更监听器(property change listener)，这是bean用来通知其属性变更的标准方式。PropertyChangeSupport类对于任何想要支持属性变更通知其属性变更监听器的bean而言是个便捷的超类。但可惜已有其他超类的类—比如JComponent—必须重新实现相应的方法。将PropertyChangeSupport重新实现为一个特质,然后将它混入到java.awt.Point类中</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">import</span> java.awt.Point
<span class="keyword">import</span> java.beans.PropertyChangeSupport

<span class="class"><span class="keyword">trait</span> <span class="title">PropertyChange</span> <span class="keyword">extends</span> <span class="title">PropertyChangeSupport</span></span>

<span class="keyword">val</span> p = <span class="keyword">new</span> Point() <span class="keyword">with</span> PropertyChange
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="scala" scheme="http://www.swanlinux.net/tags/scala/"/>
    
      <category term="《快学scala》练习" scheme="http://www.swanlinux.net/categories/%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《快学scala》第九章 文件和正则表达式]]></title>
    <link href="http://www.swanlinux.net/2014/09/10/scala_note_9/"/>
    <id>http://www.swanlinux.net/2014/09/10/scala_note_9/</id>
    <published>2014-09-10T03:32:16.000Z</published>
    <updated>2015-05-23T22:03:07.643Z</updated>
    <content type="html"><![CDATA[<p>\1. 编写一小段Scala代码，将某个文件中的行倒转顺序（将最后一行作为第一行，一次类推）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="keyword">import</span> scala.io.Source
<span class="class"><span class="keyword">object</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">App</span></span>
{
  <span class="keyword">val</span> fileName = <span class="string">"/tmp/aa.txt"</span>
  <span class="keyword">val</span> sc = Source.fromFile(fileName, <span class="string">"UTF-8"</span>);
  <span class="keyword">val</span> buf = sc.getLines.toArray
  <span class="keyword">val</span> result = buf.reverse

  <span class="keyword">val</span> ps = <span class="keyword">new</span> java.io.PrintWriter(fileName);
  result.foreach(ps.println)
  ps.flush()
  ps.close()
}
</pre></td></tr></table></figure>

<p>\2. 编写Scala程序，从一个带有制表符的文件读取内容，将每个制表符替换成一组空格，使得制表符隔开的n列仍然保持纵向对齐，并将结果写入到同一个文件</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="keyword">import</span> scala.io.Source
<span class="class"><span class="keyword">object</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">App</span></span>
{
  <span class="keyword">val</span> fileName = <span class="string">"/tmp/aa.txt"</span>
  <span class="keyword">val</span> sc = Source.fromFile(fileName, <span class="string">"UTF-8"</span>)
  <span class="keyword">val</span> result = sc.getLines.toArray.map(convert)
  <span class="keyword">val</span> ps = <span class="keyword">new</span> java.io.PrintWriter(fileName);
  result.foreach(ps.println)
  ps.flush
  ps.close

  <span class="keyword">def</span> convert(s : String) : String = {
    s.replaceAll(<span class="string">"\t"</span>, <span class="string">" "</span>)
  }
}
</pre></td></tr></table></figure>

<p>\3. 编写一小段Scala代码，从一个文件读取内容并把所有字符数大于12 的单词打印到控制台</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">import</span> scala.io.Source
<span class="class"><span class="keyword">object</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">App</span></span>
{  Source.fromFile(<span class="string">"/tmp/aa.txt"</span>, <span class="string">"UTF-8"</span>).mkString(<span class="string">""</span>).split(<span class="string">"\\s+"</span>).filter(_.toString.length &gt; <span class="number">12</span>).map(println)
}
</pre></td></tr></table></figure>

<p>\4. 编写 Scala程序，从包含浮点数的文本文件读取内容，打印出文件中所有浮点数之和、平均值、最大值和最小值</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">import</span> scala.io.Source
<span class="class"><span class="keyword">object</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">App</span></span>
{
  <span class="keyword">val</span> result = Source.fromFile(<span class="string">"/tmp/aa.txt"</span>, <span class="string">"UTF-8"</span>).mkString;
  <span class="keyword">val</span> filterResult : Array[Double] = <span class="string">"[0-9]+\\.[0-9]+"</span>.r.findAllIn(result).map(_.toDouble).toArray;

  <span class="keyword">val</span> max = filterResult.max
  <span class="keyword">val</span> min = filterResult.min
  <span class="keyword">val</span> avg = filterResult.sum / filterResult.length
  println((max, min, avg))
}
</pre></td></tr></table></figure>

<p>\5. 编写 Scala程序， 向文件中写入2的n次方及其倒数，指数n从0到20，对齐各列：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>1 	1
2 	0.5
4 	0.25
<span class="bullet">..	</span>..
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">import</span> scala.io.Source
<span class="class"><span class="keyword">object</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">App</span></span>
{
  <span class="keyword">val</span> ps = <span class="keyword">new</span> java.io.PrintWriter(<span class="string">"/tmp/aa.txt"</span>)
  <span class="keyword">for</span> (n &lt;- <span class="number">0</span> to <span class="number">20</span>) {
    <span class="keyword">val</span> value : Double = <span class="number">1</span> / (scala.math.pow(<span class="number">2</span>, n))
    ps.println(<span class="string">"\t"</span> + n.toString + <span class="string">"\t"</span> + value.toString);
  }

  ps.flush
  ps.close
}
</pre></td></tr></table></figure>

<p>\6. 编写正则表达式，匹配Java或C++ 程序代码中类似”like this, maybe with \” or \“ 这样的带引号的字符串。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>import scala.io.Source
object Test extends App
{
  val sc = Source.fromFile(<span class="string">"/tmp/aa.php"</span>, <span class="string">"UTF-8"</span>)
  val result = <span class="string">"<span class="dquote">""</span>\"</span>(\w[^\\])+(\\)?<span class="string">"<span class="dquote">""</span>"</span>.r.findAllIn(sc.mkString)
  result.foreach(println)
}
</pre></td></tr></table></figure>

<p>\7. 编写 Scala 程序， 从文本文件读取内容， 并打印出所有非浮点数的词法单元，要求使用正则表达式</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">import</span> scala.io.Source
<span class="class"><span class="keyword">object</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">App</span></span>
{
  <span class="keyword">val</span> sc = Source.fromFile(<span class="string">"/tmp/aa.php"</span>, <span class="string">"UTF-8"</span>)
  <span class="keyword">val</span> result = <span class="string">"[0-9]+\\.[0-9]+"</span>.r.replaceAllIn(sc.mkString, <span class="string">""</span>)

  println(result)
}
</pre></td></tr></table></figure>

<p>\8. 编写 Scala程序， 打印出某个网页中所有img标签的src属性，使用正则表达式和分组</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">import</span> scala.io.Source
<span class="class"><span class="keyword">object</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">App</span></span>
{
  <span class="keyword">val</span> sc = Source.fromURL(<span class="string">"http://www.baidu.com"</span>, <span class="string">"UTF-8"</span>)
    <span class="keyword">val</span> pat = <span class="string">"&lt;img[^&gt;]+src=\"([^\"]+)\"[^&gt;]+&gt;"</span>.r
  <span class="keyword">val</span> result = pat.findAllIn(sc.mkString)
  <span class="keyword">for</span> (pat(src) &lt;- result) {
    println(src)
  }
}
</pre></td></tr></table></figure>

<p>\9. 编写Scala程序，盘点给定目录及其子目录中总共有多少以.class为扩展名的文件</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="keyword">import</span> scala.collection.mutable.ArrayBuffer
<span class="keyword">import</span> java.io.File
<span class="class"><span class="keyword">object</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">App</span></span>
{
  <span class="keyword">def</span> getFiles(dir : File) : ArrayBuffer[String] = {
    <span class="keyword">val</span> files : ArrayBuffer[String] = <span class="keyword">new</span> ArrayBuffer[String]();
    <span class="keyword">val</span> children = dir.listFiles.toIterator
    <span class="keyword">for</span> (f &lt;- children) {
      <span class="keyword">if</span> (f.isDirectory && f.canRead) { <span class="comment">// 注意没有读权限的目录</span>
        <span class="keyword">val</span> childrenFiles = getFiles(f)
        files ++= childrenFiles
      } <span class="keyword">else</span> {
        <span class="keyword">if</span> (f.getName.endsWith(<span class="string">".class"</span>)) {
          files += f.getName;
        }
      }
    }

    files
  }

  println(getFiles(<span class="keyword">new</span> File(<span class="string">"/usr/home/zhongxiu"</span>)).length)
}
</pre></td></tr></table></figure>

<p>\10. 扩展那个可序列化的Person类，让它能以一个集合保存某个人的朋友信息，构造出一些Person对象，让他们中的一些人成为朋友，然后将Array[Person]保存到文件，将这个数组从文件中重新读出来，校验朋友关系是否完好</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="code"><pre><span class="keyword">import</span> scala.collection.mutable.ArrayBuffer
<span class="keyword">import</span> java.io.File
<span class="class"><span class="keyword">object</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">App</span></span>
{
  <span class="keyword">val</span> p = <span class="keyword">new</span> Person(<span class="string">"test1"</span>, <span class="number">23</span>);
  <span class="keyword">val</span> p1 = <span class="keyword">new</span> Person(<span class="string">"test2"</span>, <span class="number">24</span>);
  <span class="keyword">val</span> p2 = <span class="keyword">new</span> Person(<span class="string">"test3"</span>, <span class="number">25</span>);

  p.addFriend(p1)
  p.addFriend(p2)

  <span class="keyword">import</span> java.io._
  <span class="keyword">val</span> fileName = <span class="string">"/tmp/test.obj"</span>
  <span class="keyword">val</span> objStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(fileName))
  objStream.writeObject(p)

  <span class="keyword">val</span> in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(fileName))
  <span class="keyword">val</span> pObj = in.readObject.asInstanceOf[Person]

  println(pObj.getFirendNames)
}

<span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(val name : String, val age : Int)</span> <span class="keyword">extends</span> <span class="title">Serializable</span></span>
{
  <span class="keyword">private</span> <span class="keyword">val</span> friends : ArrayBuffer[Person] = <span class="keyword">new</span> ArrayBuffer[Person]();

  <span class="keyword">def</span> addFriend(friend : Person) {
    friends += friend
  }

  <span class="keyword">def</span> getFirendNames() : String = {
    <span class="keyword">val</span> str = <span class="string">""</span>
    friends.map(_.name).mkString
  }
}
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="scala" scheme="http://www.swanlinux.net/tags/scala/"/>
    
      <category term="《快学scala》练习" scheme="http://www.swanlinux.net/categories/%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《快学scala》第八章 继承]]></title>
    <link href="http://www.swanlinux.net/2014/09/09/scala_note_8/"/>
    <id>http://www.swanlinux.net/2014/09/09/scala_note_8/</id>
    <published>2014-09-09T06:51:16.000Z</published>
    <updated>2015-05-23T22:03:07.643Z</updated>
    <content type="html"><![CDATA[<p>\1. 扩展入校的BankAccount类，新类CheckingAccount 对每次存款和取款都收取1美元的手续费</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="class"><span class="keyword">class</span> <span class="type">BankAccount</span><span class="container">(<span class="title">initialBalance</span> : <span class="type">Double</span>)</span> {
  private var balance = initialBalance

  def deposit <span class="container">(<span class="title">amount</span> : <span class="type">Double</span>)</span> = {
    balance += amount
    balance
  }

  def withdraw<span class="container">(<span class="title">amount</span> : <span class="type">Double</span>)</span> = {
    balance -= amount
    balance
  }
}</span>
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="code"><pre><span class="class"><span class="keyword">class</span> <span class="title">BankAccount</span><span class="params">(initialBalance : Double)</span> {</span>
  <span class="keyword">private</span> <span class="keyword">var</span> balance = initialBalance

  <span class="keyword">def</span> deposit (amount : Double) = {
    balance += amount
    balance
  }

  <span class="keyword">def</span> withdraw(amount : Double) = {
    balance -= amount
    balance
  }
}

<span class="class"><span class="keyword">class</span> <span class="title">CheckingAccount</span><span class="params">(initialBalance : Double)</span> <span class="keyword">extends</span> <span class="title">BankAccount</span><span class="params">(initialBalance)</span></span>
{
  <span class="keyword">private</span> <span class="keyword">var</span> balance = initialBalance
  <span class="keyword">override</span> <span class="keyword">def</span> deposit(amount : Double) = {
    balance = <span class="keyword">super</span>.deposit(amount) - <span class="number">1</span>
    balance
  }

  <span class="keyword">override</span> <span class="keyword">def</span> withdraw(amount : Double) = {
    balance = <span class="keyword">super</span>.withdraw(amount) - <span class="number">1</span>
    balance
  }
}

<span class="class"><span class="keyword">object</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">App</span></span>
{
  <span class="keyword">val</span> ch = <span class="keyword">new</span> CheckingAccount(<span class="number">100</span>);
  println(ch.withdraw(<span class="number">2</span>))
}
</pre></td></tr></table></figure>

<p>\2. 扩展前一个练习中的BankAccount 类， 新类SavingAccount 每个月都有利息产生 (earnMonthlyInterest方法被调用)，并且有每月三次免手续费的存款和取款。在earnMonthlyInterest 方法中重置交易计数</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
</pre></td><td class="code"><pre><span class="class"><span class="keyword">class</span> <span class="title">BankAccount</span><span class="params">(initialBalance : Double)</span> {</span>
  <span class="keyword">private</span> <span class="keyword">var</span> balance = initialBalance

  <span class="keyword">def</span> deposit (amount : Double) = {
    balance += amount
    balance
  }

  <span class="keyword">def</span> withdraw(amount : Double) = {
    println(<span class="string">"base before"</span> + balance.toString)
    balance -= amount
    println(<span class="string">"base "</span> + balance.toString)
    balance
  }
}

<span class="class"><span class="keyword">class</span> <span class="title">SavingAccount</span><span class="params">(initialBalance : Double)</span> <span class="keyword">extends</span> <span class="title">BankAccount</span><span class="params">(initialBalance)</span></span>
{
  <span class="keyword">private</span> <span class="keyword">var</span> balance = initialBalance

  <span class="comment">// 存取款计数</span>
  <span class="keyword">private</span> <span class="keyword">var</span> count = <span class="number">0</span>

  <span class="keyword">private</span> <span class="keyword">val</span> earnValue = <span class="number">0</span>

  <span class="keyword">override</span> <span class="keyword">def</span> deposit (amount : Double) = {
    balance += amount;
    <span class="keyword">if</span> (count &gt; <span class="number">3</span>) {
      balance -= <span class="number">1</span>
    }
    count += <span class="number">1</span>
    balance
  }

  <span class="keyword">override</span> <span class="keyword">def</span> withdraw(amount : Double) = {
    balance -= amount
    <span class="keyword">if</span>(count &gt;= <span class="number">3</span>) {
      balance -= <span class="number">1</span>
    }
    count += <span class="number">1</span>
    balance
  }

  <span class="keyword">def</span> earnMonthlyInterest() : Double = {
    count = <span class="number">0</span>
    balance += earnValue
    balance
  }
}

<span class="class"><span class="keyword">object</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">App</span></span>
{
  <span class="keyword">val</span> ch = <span class="keyword">new</span> SavingAccount(<span class="number">100</span>);
  println(ch.withdraw(<span class="number">2</span>))
  println(ch.withdraw(<span class="number">2</span>))
  println(ch.withdraw(<span class="number">2</span>))
  println(ch.withdraw(<span class="number">2</span>))
  ch.earnMonthlyInterest
  println(ch.withdraw(<span class="number">20</span>))
  println(ch.withdraw(<span class="number">2</span>))
}
</pre></td></tr></table></figure>

<p>\4. 定义一个抽象类Item, 加入方法 price 和description. SimpleItem 是一个在构造器中给出价格和描述的物件，利用val可以重写def方法， Bundle是一个可以包含其他物件的物件，其价格是打包中所有物件的价格之和。同时提供一个将物件添加到打包当中的机制，以及一个合适的description 方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre></td><td class="code"><pre><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span></span>
{
  <span class="keyword">def</span> price : Int
  <span class="keyword">def</span> description : String
}

<span class="class"><span class="keyword">class</span> <span class="title">SimpleItem</span><span class="params">(private val initPrice : Int, private val initDescription : String)</span> <span class="keyword">extends</span> <span class="title">Item</span></span>
{
  <span class="keyword">override</span> <span class="keyword">val</span> price : Int = initPrice
  <span class="keyword">override</span> <span class="keyword">val</span> description : String = initDescription
}

<span class="class"><span class="keyword">class</span> <span class="title">Bundle</span> <span class="keyword">extends</span> <span class="title">Item</span></span>
{
  <span class="keyword">private</span> <span class="keyword">val</span> items : scala.collection.mutable.ArrayBuffer[SimpleItem] = <span class="keyword">new</span> scala.collection.mutable.ArrayBuffer[SimpleItem]();

  <span class="keyword">def</span> addItem(item : SimpleItem) {
    items += item
  }

  <span class="keyword">def</span> price() = {
    <span class="keyword">var</span> result = <span class="number">0</span>
    <span class="keyword">for</span> (i &lt;- items) {
      result += i.price
    }
    result
  }

  <span class="keyword">def</span> description() = {
    <span class="keyword">var</span> desc = <span class="keyword">new</span> scala.collection.mutable.ArrayBuffer[String]();
    <span class="keyword">for</span> (i &lt;- items) {
      desc += i.description
    }

    desc.mkString(<span class="string">","</span>)
  }
}

<span class="class"><span class="keyword">object</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">App</span></span>
{
  <span class="keyword">val</span> bundle = <span class="keyword">new</span> Bundle();
  bundle.addItem(<span class="keyword">new</span> SimpleItem(<span class="number">20</span>, <span class="string">"test1"</span>));
  bundle.addItem(<span class="keyword">new</span> SimpleItem(<span class="number">21</span>, <span class="string">"test2"</span>));
  bundle.addItem(<span class="keyword">new</span> SimpleItem(<span class="number">22</span>, <span class="string">"test3"</span>));

  println(bundle.price);
  println(bundle.description);
}
</pre></td></tr></table></figure>

<p>\5. 设计一个Point 类， 其 x 和 y 坐标可以通过构造器提供，提供一个子类 LabeledPoint , 其构造器接收一个标签值和 x, y 坐标， 比如： new LabeledPoint(“Black Thursday”, 1929, 230.07)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span><span class="params">(val x : Int, val y : Int)</span></span>
{
}

<span class="class"><span class="keyword">class</span> <span class="title">LabeledPoint</span><span class="params">(var label : String, x : Int, y : Int)</span> <span class="keyword">extends</span> <span class="title">Point</span><span class="params">(x, y)</span></span>
{

}

<span class="class"><span class="keyword">object</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">App</span></span>
{
  <span class="keyword">val</span> p = <span class="keyword">new</span> LabeledPoint(<span class="string">"Black Thursday"</span>, <span class="number">1929</span>, <span class="number">2307</span>)
  println(p.label)
}
</pre></td></tr></table></figure>

<p>\6. 定义一个抽象类 Shape、一个抽象方法centerPoint, 以及该抽象类的子类 Rectangle 和 Circle , 为子类提供合适的构造器，并重写 centerPoint 方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span>
{
  <span class="keyword">def</span> centerPoint : (Double, Double)
}

<span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span><span class="params">(val height : Int, val width : Int)</span></span>
{
  <span class="keyword">def</span> centerPoint : (Double, Double) = {
    <span class="keyword">val</span> x = height.toDouble / <span class="number">2.0</span>
    <span class="keyword">val</span> y = width.toDouble / <span class="number">2.0</span>
    (x, y)
  }
}

<span class="class"><span class="keyword">class</span> <span class="title">Circle</span><span class="params">(val diameter : Int)</span></span>
{
  <span class="keyword">def</span> centerPoint : (Double, Double) = {
    <span class="keyword">val</span> x = <span class="number">0</span>
    <span class="keyword">val</span> y = diameter.toDouble / <span class="number">2.0</span>
    (x, y)
  }
}

<span class="class"><span class="keyword">object</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">App</span></span>
{
  <span class="keyword">val</span> rect = <span class="keyword">new</span> Rectangle(<span class="number">2</span>, <span class="number">3</span>);
  println(rect.centerPoint);
  <span class="keyword">val</span> cir  = <span class="keyword">new</span> Circle(<span class="number">30</span>)
  println(cir.centerPoint)
}
</pre></td></tr></table></figure>

<p>\7. 提供一个Square 类， 扩展自 java.awt.Rectangle 并且有三个构造器：一个以给定的端点和宽度构造正方形，一个以(0, 0) 为端点和给定的宽度构造正方形，一个以(0， 0) 为端点、0为宽度构造正方形</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="class"><span class="keyword">class</span> <span class="title">Square</span><span class="params">(x : Int, y : Int, width : Int)</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">awt</span>.<span class="title">Rectangle</span><span class="params">(x, y, width, width)</span></span>
{
  <span class="keyword">def</span> <span class="keyword">this</span>(x : Int, y : Int) {
    <span class="keyword">this</span>(x, y, <span class="number">10</span>)
  }

  <span class="keyword">def</span> <span class="keyword">this</span>(width : Int) {
    <span class="keyword">this</span>(<span class="number">0</span>, <span class="number">0</span>, width)
  }
}

<span class="class"><span class="keyword">object</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">App</span></span>
{
  <span class="keyword">val</span> rect = <span class="keyword">new</span> Square(<span class="number">2</span>, <span class="number">3</span>);
  println(rect);
}
</pre></td></tr></table></figure>

<p>\8. 编译 8.6 节中的Person 和 SecretAgent 类并使用 javap 分析类文件。总共有多少name 的getter方法？它们分别取什么值？ （提示：可以用 -c 和 -private 选项）</p>
<p>\9. 在 8.10 节的Creature 类中， 将 val range 替换成一个 def ， 如果你在Ant子类中也用 def的话有什么效果？如果在子类中使用 val又会有什么效果？ 为什么？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="class"><span class="keyword">class</span> <span class="title">Creature</span> {</span>
  <span class="keyword">def</span> range  = <span class="number">10</span>

  <span class="keyword">val</span> env : Array[Int] = <span class="keyword">new</span> Array[Int](range)
}

<span class="class"><span class="keyword">class</span> <span class="title">Ant</span> <span class="keyword">extends</span> <span class="title">Creature</span></span>
{
  <span class="keyword">override</span> <span class="keyword">def</span> range = <span class="number">2</span>
} 

<span class="class"><span class="keyword">object</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">App</span></span>
{
  <span class="keyword">val</span> test = <span class="keyword">new</span> Ant();
  println(test.env.length);
}
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="scala" scheme="http://www.swanlinux.net/tags/scala/"/>
    
      <category term="《快学scala》练习" scheme="http://www.swanlinux.net/categories/%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《快学scala》第七章 包和引入]]></title>
    <link href="http://www.swanlinux.net/2014/09/09/scala_note_7/"/>
    <id>http://www.swanlinux.net/2014/09/09/scala_note_7/</id>
    <published>2014-09-09T03:40:16.000Z</published>
    <updated>2015-05-23T22:03:07.643Z</updated>
    <content type="html"><![CDATA[<p>\1. 编写示例程序，展示为什么<br>package com.horstmann.impatient<br>不同于<br>package com<br>package horstmann<br>package impatient</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="comment">// 假如有这样一个包</span>
<span class="keyword">package</span> com {
  <span class="class"><span class="keyword">object</span> <span class="title">Test1</span>{</span>}
  <span class="keyword">package</span> horstmann {
    <span class="class"><span class="keyword">object</span> <span class="title">Test2</span> {</span>}
    <span class="keyword">package</span> impatient {
      <span class="class"><span class="keyword">object</span> <span class="title">Test3</span> {</span>}
    }       
  }         
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="keyword">package</span> com
<span class="keyword">package</span> horstmann
<span class="keyword">package</span> impatient

<span class="class"><span class="keyword">object</span> <span class="title">Test4</span> {</span>
  <span class="keyword">val</span> x = Test1 <span class="comment">// 可以访问</span>
  <span class="keyword">val</span> y = Test2 <span class="comment">// 可以访问</span>
  <span class="keyword">val</span> z = Test3 <span class="comment">// 可以访问</span>
}
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">package</span> com.horstmann.impatient

<span class="class"><span class="keyword">object</span> <span class="title">Test4</span> {</span>
  <span class="keyword">val</span> x = Test1 <span class="comment">// 不可以访问</span>
  <span class="keyword">val</span> y = Test2 <span class="comment">// 不可以访问</span>
  <span class="keyword">val</span> z = Test3 <span class="comment">// 可以访问</span>
}
</pre></td></tr></table></figure>

<p>\2. 编写一段让你的Scala朋友们感到困惑的代码，使用一个不在顶部的com包。 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="keyword">package</span> com.horstmann.impatient {
  <span class="class"><span class="keyword">object</span> <span class="title">Funcy</span> {</span>
    <span class="keyword">def</span> foo {
      println(<span class="string">"top level com"</span>);
    }
  }
}
<span class="keyword">package</span> scala.com.horstmann.impatient {
  <span class="class"><span class="keyword">object</span> <span class="title">Funcy</span> {</span>
    <span class="keyword">def</span> foo {
      println(<span class="string">"not top level com"</span>);
    }
  }
}

<span class="keyword">import</span> scala._ <span class="comment">// 如果去掉用输出 "top level com" , 否则输出 "not top level com"</span>
<span class="class"><span class="keyword">object</span> <span class="title">ScalaApp1</span> {</span>
  <span class="keyword">def</span> main(args : Array[String]) {
    com.horstmann.impatient.Funcy.foo
  }
}
</pre></td></tr></table></figure>

<p>\3. 编写一个包random，加入函数nextInt():Int、nextDouble: Double和setSeed(seed:Int):Unit。生成随机数的算法使用线性同余生成器：<br> 后值=(前值 x * a + b) mod 2^n<br>其中，a=1664525，b=1013904223，n=32，前值的初始值为seed。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="code"><pre><span class="keyword">package</span> random {
  <span class="keyword">package</span> <span class="class"><span class="keyword">object</span> <span class="title">random</span> {</span>
    <span class="keyword">val</span> a : Long = <span class="number">1664525</span>;
    <span class="keyword">val</span> b : Long = <span class="number">1013904223</span>;
    <span class="keyword">val</span> n : Int = <span class="number">32</span>;
    <span class="keyword">var</span> prev : Int = <span class="number">1</span>;

    <span class="keyword">def</span> nextInt() : Int = {
      <span class="keyword">val</span> rand = (prev * a + b) % n
      setSeed(rand.toInt)
      rand.toInt  
    }             
                  
    <span class="keyword">def</span> setSeed(seed : Int) : Unit = {
      <span class="keyword">this</span>.prev = seed 
    } 
    
    <span class="keyword">def</span> nextDouble() : Double = {
      nextInt.toDouble / n 
    } 
  } 
} 

<span class="class"><span class="keyword">object</span> <span class="title">TestRandom</span> {</span>
  <span class="keyword">def</span> main(args : Array[String]) {
    <span class="keyword">import</span> random._
    random.setSeed(<span class="number">999</span>);
    <span class="keyword">for</span> (_ &lt;- <span class="number">1.</span>to(<span class="number">100</span>, <span class="number">1</span>)) {
      println(random.nextInt);
    } 
    <span class="keyword">for</span> (_ &lt;- <span class="number">1.</span>to(<span class="number">100</span>, <span class="number">1</span>)) {
      println(random.nextDouble);
    } 
  } 
}
</pre></td></tr></table></figure>

<p>\4. 在你看来，Scala的设计者为什么要提供package object语法而不是简单地让你将函数和变量添加到包中呢？ </p>
<p>这是因为Java虚拟机的局限  </p>
<p>\5. private[com] def giveRaise(rate:Double)的含义是什么？有用吗？</p>
<p>限制giveRaise函数在com包内可见  </p>
<p>\6. 编写一段程序，将Java哈希映射中的所有元素拷贝到Scala哈希映射。用引入语句重命名这两个类。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="keyword">import</span> java.util.{HashMap =&gt; JavaHashMap}
<span class="keyword">import</span> scala.collection.JavaConversions.mapAsScalaMap
<span class="keyword">import</span> scala.collection.mutable.{Map =&gt; ScalaHashMap}

object TestMap7 {
  def main(args : Array[String]) {
    <span class="keyword">var</span> <span class="keyword">map</span> = <span class="built_in">new</span> JavaHashMap[String, Int]();
    <span class="keyword">map</span>.put(<span class="string">"test1"</span>,<span class="number"> 1</span>);
    <span class="keyword">map</span>.put(<span class="string">"test2"</span>,<span class="number"> 3</span>);
    <span class="keyword">map</span>.put(<span class="string">"test3"</span>,<span class="number"> 5</span>);

    val m2 : ScalaHashMap[String, Int] = <span class="keyword">map</span>;
    <span class="built_in">println</span>(m2.mkString(<span class="string">","</span>))
  }         
}
</pre></td></tr></table></figure>

<p>\7. 在前一个练习中，将所有引入语句移动到尽可能小的作用域里。 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre>object TestMap7 {
  def main(args : Array[String]) {
    <span class="keyword">import</span> java.util.{HashMap =&gt; JavaHashMap}
    <span class="keyword">import</span> scala.collection.JavaConversions.mapAsScalaMap
    <span class="keyword">import</span> scala.collection.mutable.{Map =&gt; ScalaHashMap}
    
    <span class="keyword">var</span> <span class="keyword">map</span> = <span class="built_in">new</span> JavaHashMap[String, Int]();
    <span class="keyword">map</span>.put(<span class="string">"test1"</span>,<span class="number"> 1</span>);
    <span class="keyword">map</span>.put(<span class="string">"test2"</span>,<span class="number"> 3</span>);
    <span class="keyword">map</span>.put(<span class="string">"test3"</span>,<span class="number"> 5</span>);

    val m2 : ScalaHashMap[String, Int] = <span class="keyword">map</span>;
    <span class="built_in">println</span>(m2.mkString(<span class="string">","</span>))
  }
}
</pre></td></tr></table></figure>

<p>\8. 以下代码的作用是什么？这是个好主意吗？<br>import java.<em><br>import javax.</em></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>完全引入java和javax包的所有成员，在编写代码时可以使用更短的名称。  
从多个源引入大量名称总是让人担心，会增加名称冲突的风险，通过将引入放置在需要这些引入的地方，可以大幅减少可能的名称冲突。
</pre></td></tr></table></figure>

<p>\9. 编写一段程序，引入java.lang.System类，从user.name系统属性读取用户名，从Console对象读取一个密码，如果密码不是”secret”，则在标准错误流中打印一个消息，如果密码是“secret”，则在标准输出流中打印一个问候消息。不要使用任何其他引入，也不要使用任何限定词（带句点的那种）。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="keyword">import</span> java.lang.System.getProperty
<span class="keyword">import</span> java.lang.System.err.{println =&gt; perror}

<span class="class"><span class="keyword">object</span> <span class="title">TestErr</span> {</span>
  <span class="keyword">def</span> main(args : Array[String]) {
    <span class="keyword">val</span> name = getProperty(<span class="string">"user.name"</span>);
    print(<span class="string">"password:"</span>);
    <span class="keyword">if</span> (readLine() == <span class="string">"secret"</span>) {
      println(<span class="string">"welcome, "</span> + name);
    } <span class="keyword">else</span> {
      perror(<span class="string">"wrong password"</span>);
    } 
  } 
}
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="scala" scheme="http://www.swanlinux.net/tags/scala/"/>
    
      <category term="《快学scala》练习" scheme="http://www.swanlinux.net/categories/%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《快学scala》第六章 对象]]></title>
    <link href="http://www.swanlinux.net/2014/09/08/scala_note_6/"/>
    <id>http://www.swanlinux.net/2014/09/08/scala_note_6/</id>
    <published>2014-09-08T05:56:16.000Z</published>
    <updated>2015-05-23T22:03:07.643Z</updated>
    <content type="html"><![CDATA[<p>\1. 编写一个Conversions对象，加入inchesToCentimeters、gallonsToLiters和milesToKilometers方法。 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="keyword">object</span> Conversions
{
  def inchesToCentimeters(<span class="keyword">value</span> : Double) = {
    <span class="keyword">value</span> * <span class="number">2.54</span>
  }

  def gallonsToLiters(<span class="keyword">value</span> : Double) = {
    <span class="number">3.78541178</span> * <span class="keyword">value</span>
  }

  def milesToKilometers(<span class="keyword">value</span> : Double) = {
    <span class="number">1.609344</span> * <span class="keyword">value</span>
  }
} 

<span class="keyword">object</span> TestApp
{
  def main(args : Array[String]) {
    println(Conversions.inchesToCentimeters(<span class="number">3</span>));
  }
}
</pre></td></tr></table></figure>

<p>\2. 前一个练习不是很面向对象，提供一个通用的超类UnitConversion并定义扩展该超类的InchesToCentimeters、GallonsToLiters和MilesToKilometers对象。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="code"><pre><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">UnitConversion</span></span>
{
  <span class="keyword">def</span> convert(value : Double) : Double
}

<span class="class"><span class="keyword">object</span> <span class="title">inchesToCentimeters</span> <span class="keyword">extends</span> <span class="title">UnitConversion</span></span>
{
  <span class="keyword">def</span> convert(value : Double) = {
    value * <span class="number">2.54</span>
  }
}

<span class="class"><span class="keyword">object</span> <span class="title">gallonsToLiters</span> <span class="keyword">extends</span> <span class="title">UnitConversion</span></span>
{
  <span class="keyword">def</span> convert(value : Double) = {
    value * <span class="number">3.78541178</span>
  } 
}
     
<span class="class"><span class="keyword">object</span> <span class="title">milesToKilometers</span> <span class="keyword">extends</span> <span class="title">UnitConversion</span></span>
{
  <span class="keyword">def</span> convert(value : Double) = {
    value * <span class="number">1.609344</span>
  } 
} 


<span class="class"><span class="keyword">object</span> <span class="title">TestApp</span></span>
{
  <span class="keyword">def</span> main(args : Array[String]) {
    println(inchesToCentimeters.convert(<span class="number">3</span>));
  }
}
</pre></td></tr></table></figure>

<p>\3. 定义一个扩展自java.awt.Point的Origin对象。为什么说这实际上不是个好主意？（仔细看Point类的方法） </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">Origin</span></span>
{
  <span class="keyword">def</span> apply() = <span class="keyword">new</span> java.awt.Point()
}

<span class="class"><span class="keyword">object</span> <span class="title">TestApp</span></span>
{
  <span class="keyword">def</span> main(args : Array[String]) {
    println(Origin());
  } 
}
</pre></td></tr></table></figure>

<p>\4. 定义一个Point类和一个伴生对象，使得我们可以不用new而直接用Point(3,4)来构造Point实例。 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="class"><span class="keyword">class</span> <span class="type">Point</span><span class="container">(<span class="title">val</span> <span class="title">x</span> : <span class="type">Int</span>, <span class="title">val</span> <span class="title">y</span> : <span class="type">Int</span>)</span> {

}
object <span class="type">Point</span>
{
  def apply<span class="container">(<span class="title">x</span> : <span class="type">Int</span>, <span class="title">y</span> : <span class="type">Int</span>)</span> = new <span class="type">Point</span><span class="container">(<span class="title">x</span>, <span class="title">y</span>)</span>
}

object <span class="type">TestApp</span>
{
  def main<span class="container">(<span class="title">args</span> : <span class="type">Array</span>[<span class="type">String</span>])</span> {
    val p = <span class="type">Point</span><span class="container">(3, 4)</span>;
    println<span class="container">(<span class="title">p</span>.<span class="title">x</span>)</span>
  } 
}</span>
</pre></td></tr></table></figure>

<p>\5. 编写一个Scala应用程序，使用App特质，以反序打印命令行参数，用空格隔开。 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">TestApp</span> <span class="keyword">extends</span> <span class="title">App</span></span>
{
  println(args.reverse.mkString(<span class="string">","</span>))
}
</pre></td></tr></table></figure>

<p>\6. 编写一个扑克牌4种花色的枚举，让其toString方法分别返回♣、♦、♥和♠。 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="keyword">object</span> TestApp extends App
{
  <span class="keyword">for</span>(c &lt;- EnumTest.values) {
    println(c.toString)
  }
}                  
                   
<span class="keyword">object</span> EnumTest extends Enumeration
{
  <span class="keyword">val</span> Club = Value(<span class="number">0</span>, <span class="string">"♣"</span>)
  <span class="keyword">val</span> Diomand = Value(<span class="number">1</span>, <span class="string">"♦"</span>)
  <span class="keyword">val</span> Heart = Value(<span class="number">2</span>, <span class="string">"♥"</span>)
  <span class="keyword">val</span> Spade = Value(<span class="number">3</span>, <span class="string">"♠))
}</span>
</pre></td></tr></table></figure>

<p>\7. 编写一个函数，检查某张牌的花色是否为红色。 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">TestApp</span> <span class="keyword">extends</span> <span class="title">App</span></span>
{
  <span class="keyword">for</span>(c &lt;- EnumTest.values) {
    println(c.toString)
    println(check(c))
  }

  <span class="keyword">def</span> check(card : EnumTest.Value) = {
    <span class="keyword">if</span> (card == EnumTest.Heart) {
      <span class="keyword">true</span>
    } <span class="keyword">else</span> {
      <span class="keyword">false</span>
    }
  }
}

<span class="class"><span class="keyword">object</span> <span class="title">EnumTest</span> <span class="keyword">extends</span> <span class="title">Enumeration</span></span>
{
  <span class="keyword">val</span> Club = Value(<span class="number">0</span>, <span class="string">"♣"</span>)
  <span class="keyword">val</span> Diomand = Value(<span class="number">1</span>, <span class="string">"♦"</span>)
  <span class="keyword">val</span> Heart = Value(<span class="number">2</span>, <span class="string">"♥"</span>)
  <span class="keyword">val</span> Spade = Value(<span class="number">3</span>, <span class="string">"♠"</span>)
}
</pre></td></tr></table></figure>

<p>\8. 编写一个枚举，描述RGB立方体的8个角。ID使用颜色值（例如，红色是0xff0000）。 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">RGBCube</span> <span class="keyword">extends</span> <span class="title">Enumeration</span> {</span>
  <span class="keyword">val</span> R = Value(<span class="number">0xff0000</span>)
  <span class="keyword">val</span> G = Value(<span class="number">0x00ff00</span>)
  <span class="keyword">val</span> B = Value(<span class="number">0x0000ff</span>)
  <span class="keyword">val</span> RG = Value(<span class="number">0xffff00</span>)
  <span class="keyword">val</span> RB = Value(<span class="number">0xff00ff</span>)
  <span class="keyword">val</span> GB = Value(<span class="number">0x00ffff</span>)
  <span class="keyword">val</span> RGB = Value(<span class="number">0xffffff</span>)
  <span class="keyword">val</span> BLACK = Value(<span class="number">0x000000</span>)
} 

<span class="class"><span class="keyword">object</span> <span class="title">ScalaApp</span> {</span>
  <span class="keyword">def</span> main(args: Array[String]) {
    <span class="keyword">for</span> (c &lt;- RGBCube.values) { 
      printf(<span class="string">"#%06x\n"</span>, c.id) 
    } 
  } 
}
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="scala" scheme="http://www.swanlinux.net/tags/scala/"/>
    
      <category term="《快学scala》练习" scheme="http://www.swanlinux.net/categories/%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《快学scala》第五章 类]]></title>
    <link href="http://www.swanlinux.net/2014/09/08/scala_note_5/"/>
    <id>http://www.swanlinux.net/2014/09/08/scala_note_5/</id>
    <published>2014-09-08T02:56:16.000Z</published>
    <updated>2015-05-23T22:03:07.643Z</updated>
    <content type="html"><![CDATA[<p>\1. 改进5.1节的Counter类，让它不要在Int.MaxValue时变成负数。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">TestC</span> {</span>
  <span class="keyword">def</span> main(args : Array[String]) {
    <span class="keyword">val</span> count = <span class="keyword">new</span> Counter();
    <span class="keyword">for</span> (_ &lt;- <span class="number">1</span> to Int.MaxValue) {
      count.increment();
    }
    println(count.current)
  }
}

<span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span>
{ 
  <span class="keyword">private</span> <span class="keyword">var</span> value = <span class="number">0</span>
  
  <span class="keyword">def</span> increment() { 
    <span class="keyword">if</span> ((value + <span class="number">1</span>).isValidInt) {
      value += <span class="number">1</span>
    }
  }
  
  <span class="keyword">def</span> current() = value
}
</pre></td></tr></table></figure>

<p>\2. 编写一个BankAccount类，加入deposit和withdraw方法，和一个只读的balance属性。  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">TestC</span> {</span>
  <span class="keyword">def</span> main(args : Array[String]) {
    <span class="keyword">val</span> bank = <span class="keyword">new</span> BankAccount(<span class="number">200</span>);
    bank.deposit
    bank.withdraw
    println(bank.balance)
  }
}

<span class="class"><span class="keyword">class</span> <span class="title">BankAccount</span><span class="params">(val balance : Int)</span></span>
{
  <span class="keyword">def</span> deposit = {
    println(<span class="string">"deposit function"</span>);
  }

  <span class="keyword">def</span> withdraw = {
    println(<span class="string">"withdraw function"</span>);
  }
}
</pre></td></tr></table></figure>

<p>\3. 编写一个Time类，加入只读属性hours和minutes，和一个检查某一时刻是否早于另一时刻的方法before(other: Time): boolean。Time对象应该以new Time(hrs, min)方式构建，其中hrs小时数以军用时间格式呈现（介于0和23之间）。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="keyword">package</span> net.swanlinux.www.test

<span class="class"><span class="keyword">object</span> <span class="title">TestC</span> {</span>
  <span class="keyword">def</span> main(args : Array[String]) {
    <span class="keyword">val</span> time = <span class="keyword">new</span> Time(<span class="number">23</span>, <span class="number">9</span>);
    println(time.before(<span class="keyword">new</span> Time(<span class="number">23</span>, <span class="number">10</span>)))
  } 
} 

<span class="class"><span class="keyword">class</span> <span class="title">Time</span><span class="params">(private var hrs : Int, private var min : Int)</span></span>
{
  <span class="comment">// 格式化合法的时间</span>
  hrs = hrs % <span class="number">24</span>
  min = min % <span class="number">60</span>
  
  <span class="keyword">def</span> before(other : Time) : Boolean = {
    other.hours &gt; <span class="keyword">this</span>.hours || (other.hours == <span class="keyword">this</span>.hours && other.minutes &gt; <span class="keyword">this</span>.minutes)
  } 
  
  <span class="keyword">def</span> hours = hrs
  
  <span class="keyword">def</span> minutes = min
}
</pre></td></tr></table></figure>

<p>\4. 重新实现前一个练习中的Time类，将内部呈现改成自午夜起的分钟数（介于0到24x60-1之间）。不要改变公有接口。也就是说，客户端代码不应因你的修改而受影响。 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="keyword">package</span> net.swanlinux.www.test

<span class="class"><span class="keyword">object</span> <span class="title">TestC</span> {</span>
  <span class="keyword">def</span> main(args : Array[String]) {
    <span class="keyword">val</span> time = <span class="keyword">new</span> Time(<span class="number">23</span>, <span class="number">9</span>);
    println(time.before(<span class="keyword">new</span> Time(<span class="number">23</span>, <span class="number">10</span>)))
  } 
} 

<span class="class"><span class="keyword">class</span> <span class="title">Time</span><span class="params">(private var hrs : Int, private var min : Int)</span></span>
{
  <span class="comment">// 格式化合法的时间</span>
  hrs = hrs % <span class="number">24</span>
  min = min % <span class="number">60</span>
  
  <span class="keyword">def</span> before(other : Time) : Boolean = {
    other.total &gt; <span class="keyword">this</span>.total
  }                     
                        
  <span class="keyword">def</span> hours = hrs

  <span class="keyword">def</span> minutes = min

  <span class="keyword">def</span> total = (hrs * <span class="number">60</span> + min)
}
</pre></td></tr></table></figure>

<p>\5. 创建一个Student类，加入可读写的JavaBeans属性name(类型为String)和id(类型为Long)。 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="keyword">package</span> net.swanlinux.www.test
<span class="keyword">import</span> scala.reflect.BeanProperty

<span class="class"><span class="keyword">object</span> <span class="title">TestC</span> {</span>
  <span class="keyword">def</span> main(args : Array[String]) {
    <span class="keyword">val</span> stu = <span class="keyword">new</span> Student(<span class="string">"test"</span>, <span class="number">4000</span>)
    println(stu.getName);
    println(stu.getId);
  }
} 

<span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(<span class="annotation">@BeanProperty</span> var name : String, <span class="annotation">@BeanProperty</span> var id : Long)</span></span>
{
}
</pre></td></tr></table></figure>

<p>\6. 在5.2节的Person类中提供一个主构造器，将负年龄转换为0。 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="keyword">package</span> net.swanlinux.www.test

<span class="class"><span class="keyword">object</span> <span class="title">TestC</span> {</span>
  <span class="keyword">def</span> main(args : Array[String]) {
    <span class="keyword">val</span> per = <span class="keyword">new</span> Person();
    per.age = -<span class="number">2</span>
    println(per.age)
  } 
} 

<span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>
{
  <span class="keyword">private</span> <span class="keyword">var</span> privateAge = <span class="number">0</span>

  <span class="keyword">def</span> age_=(newValue : Int) { 
    <span class="keyword">if</span> (newValue &lt; <span class="number">0</span>) {
      privateAge = <span class="number">0</span>
    } <span class="keyword">else</span> {
      privateAge = newValue
    }             
  }               
     
  <span class="keyword">def</span> age = privateAge
}
</pre></td></tr></table></figure>

<p>\7. 编写一个Person类，其主构造器接受一个字符串，该字符串包含名字、空格和姓，如new Person(“Fred Smith”)。提供只读属性firstName和LastName。 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="keyword">package</span> net.swanlinux.www.test

<span class="class"><span class="keyword">object</span> <span class="title">TestC</span> {</span>
  <span class="keyword">def</span> main(args : Array[String]) {
    <span class="keyword">val</span> per = <span class="keyword">new</span> Person(<span class="string">"Fred Smith"</span>);
    println(per.firstName)
    println(per.lastName)
  } 
} 

<span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(val name : String)</span></span>
{
  <span class="keyword">val</span> firstName = name.split(<span class="string">" "</span>)(<span class="number">0</span>)
  <span class="keyword">val</span> lastName = name.split(<span class="string">" "</span>)(<span class="number">1</span>)
}
</pre></td></tr></table></figure>

<p>\8. 创建一个Car类，以只读属性对应制造商、型号名称、型号年份以及一个可读写的属性用于车牌。提供四组构造器。每一个构造器都要求制造商和型号名称为必填。型号年份以及车牌为可选，如果未填，则型号年份设置为-1，车牌设置为空字符串。你会选择哪一个作为你的主构造器？为什么？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="code"><pre>
package net.swanlinux.www.test

object TestC {
  def main(args : <span class="built_in">Array</span>[<span class="built_in">String</span>]) {
    val car = <span class="keyword">new</span> Car(<span class="string">"Fred Smith"</span>, <span class="string">"test"</span>, <span class="number">2008</span>, <span class="string">"JX222"</span>);
    println(car.model)
  } 
} 

<span class="keyword">class</span> Car(val maker : <span class="built_in">String</span>, val name : <span class="built_in">String</span>)
{
  private <span class="keyword">var</span> privateModel = -<span class="number">1</span>
  <span class="keyword">var</span> licence = <span class="string">""</span>
  
  def <span class="keyword">this</span>(maker : <span class="built_in">String</span>, name : <span class="built_in">String</span>, model : Int) {
    <span class="keyword">this</span>(maker, name)
    <span class="keyword">this</span>.privateModel = model
  }     
        
  def <span class="keyword">this</span>(maker : <span class="built_in">String</span>, name : <span class="built_in">String</span>, model : Int, licence : <span class="built_in">String</span>) {
    <span class="keyword">this</span>(maker, name, model)
    <span class="keyword">this</span>.licence = licence
  } 
  
  def <span class="keyword">this</span>(maker : <span class="built_in">String</span>, name : <span class="built_in">String</span>, licence : <span class="built_in">String</span>) {
    <span class="keyword">this</span>(maker, name)
    <span class="keyword">this</span>.licence = licence
  } 
  
  def model = privateModel
}
</pre></td></tr></table></figure>

<p>\10. 考虑如下类：</p>
<p>class Employee(val name: String, var salary: Double) {</p>
<p>  def this() {this(“John Q. Public”, 0.0)}</p>
<p>}</p>
<p>重写该类，使用显式的字段定义，和一个缺省主构造器。你更倾向于使用哪一种形式？为什么？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="keyword">package</span> net.swanlinux.www.test

<span class="class"><span class="keyword">object</span> <span class="title">TestC</span> {</span>
  <span class="keyword">def</span> main(args : Array[String]) {
    <span class="keyword">val</span> em = <span class="keyword">new</span> Employee();
    println(em.name)
  } 
} 

<span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>
{
  <span class="keyword">private</span> <span class="keyword">var</span> privateName = <span class="string">"John Q. Public"</span>
  <span class="keyword">private</span> <span class="keyword">var</span> privateSalary = <span class="number">0.0</span>
  
  <span class="keyword">def</span> <span class="keyword">this</span>(name : String, salary : Double) {
    <span class="keyword">this</span>()
    <span class="keyword">this</span>.privateName = name
    <span class="keyword">this</span>.privateSalary = salary
  } 
  
  <span class="keyword">def</span> name = privateName
  
  <span class="keyword">def</span> salary = privateSalary
}
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="scala" scheme="http://www.swanlinux.net/tags/scala/"/>
    
      <category term="《快学scala》练习" scheme="http://www.swanlinux.net/categories/%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《快学scala》第四章 映射和元组]]></title>
    <link href="http://www.swanlinux.net/2014/09/08/scala_note_4/"/>
    <id>http://www.swanlinux.net/2014/09/08/scala_note_4/</id>
    <published>2014-09-07T18:13:16.000Z</published>
    <updated>2015-05-23T22:03:07.643Z</updated>
    <content type="html"><![CDATA[<p>\1.设置一个映射，其中包含你想要的一些装备，以及它们的价格。然后构建另一个映射，采用同一组键，但在价格上打9折。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">MapApp</span></span>
{
  <span class="keyword">def</span> main(args: Array[String])  = {
    <span class="keyword">val</span> produce : Map[String, Int] = Map(<span class="string">"test1"</span> -&gt; <span class="number">10</span>, <span class="string">"test2"</span> -&gt; <span class="number">300</span>);
    <span class="keyword">val</span> result = (<span class="keyword">for</span> ((k, v) &lt;- produce) <span class="keyword">yield</span> {
      (k, v * <span class="number">0.9</span>)
    })
   
    <span class="keyword">for</span> ((k, v) &lt;- result) {
      println(k);
      println(v);
    }
  }
}
</pre></td></tr></table></figure>

<p>\2. 编写一段程序，从文件中读取单词。用一个可变映射来清点每一个单词出现的频率。 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre>object MapApp
{
  def main(args: Array[String])  = {
    charCount()
  }

  def charCount() = {
    val <span class="keyword">in</span>  = new java<span class="preprocessor">.util</span><span class="preprocessor">.Scanner</span>(new java<span class="preprocessor">.io</span><span class="preprocessor">.File</span>(<span class="string">"/tmp/test.txt"</span>))<span class="comment">;</span>
    val map = new scala<span class="preprocessor">.collection</span><span class="preprocessor">.mutable</span><span class="preprocessor">.HashMap</span>[String, Int]()<span class="comment">;</span>
    while (<span class="keyword">in</span><span class="preprocessor">.hasNext</span>()) {
      val str = <span class="keyword">in</span><span class="preprocessor">.next</span>()<span class="comment">;</span>
      map(str) = map<span class="preprocessor">.getOrElse</span>(str, <span class="number">0</span>) + <span class="number">1</span><span class="comment">;</span>
    }

    println(map<span class="preprocessor">.mkString</span>(<span class="string">","</span>))<span class="comment">;</span>
  }
}
</pre></td></tr></table></figure>

<p>\3. 重复前一个练习，这次用不可变的映射。 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">MapApp</span></span>
{
  <span class="keyword">def</span> main(args: Array[String])  = {
    charCount()
  }

  <span class="keyword">def</span> charCount() = {
    <span class="keyword">val</span> in  = <span class="keyword">new</span> java.util.Scanner(<span class="keyword">new</span> java.io.File(<span class="string">"/tmp/test.txt"</span>));
    <span class="keyword">val</span> map = Map[String, Int]();
    <span class="keyword">var</span> m   = map
    <span class="keyword">while</span> (in.hasNext()) {
      <span class="keyword">val</span> str = in.next();
      m += (str -&gt; (m.getOrElse(str, <span class="number">0</span>) + <span class="number">1</span>));
    }

    println(m.mkString(<span class="string">","</span>));
  }
}
</pre></td></tr></table></figure>

<p>\4. 重复前一个练习，这次用已排序的映射，以便单词可以按顺序打印出来。 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre>object MapApp
{
  def main(args: Array[String])  = {
    charCount()
  } 
    
  def charCount() = {
    val <span class="keyword">in</span>  = new java<span class="preprocessor">.util</span><span class="preprocessor">.Scanner</span>(new java<span class="preprocessor">.io</span><span class="preprocessor">.File</span>(<span class="string">"/tmp/test.txt"</span>))<span class="comment">;</span>
    val map = scala<span class="preprocessor">.collection</span><span class="preprocessor">.immutable</span><span class="preprocessor">.SortedMap</span>[String, Int]()<span class="comment">;</span>
    var m   = map<span class="comment">;</span>
    while (<span class="keyword">in</span><span class="preprocessor">.hasNext</span>()) {
      val str = <span class="keyword">in</span><span class="preprocessor">.next</span>()<span class="comment">;</span>
      m += (str -&gt; (m<span class="preprocessor">.getOrElse</span>(str, <span class="number">0</span>) + <span class="number">1</span>))<span class="comment">;</span>
    }
    
    println(m<span class="preprocessor">.mkString</span>(<span class="string">","</span>))<span class="comment">;</span>
  }
}
</pre></td></tr></table></figure>

<p>\5. 重复前一个练习，这次用java.util.TreeMap并使之适用于Scala API。 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre>import scala<span class="preprocessor">.collection</span><span class="preprocessor">.JavaConversions</span><span class="preprocessor">.mapAsScalaMap</span>

object MapApp
{
  def main(args: Array[String])  = {
    charCount()
  }

  def charCount() = {
    val <span class="keyword">in</span>  = new java<span class="preprocessor">.util</span><span class="preprocessor">.Scanner</span>(new java<span class="preprocessor">.io</span><span class="preprocessor">.File</span>(<span class="string">"/tmp/test.txt"</span>))<span class="comment">;</span>
    val map : scala<span class="preprocessor">.collection</span><span class="preprocessor">.mutable</span><span class="preprocessor">.Map</span>[String, Int] = new java<span class="preprocessor">.util</span><span class="preprocessor">.TreeMap</span>[String, Int]<span class="comment">;</span>
    while (<span class="keyword">in</span><span class="preprocessor">.hasNext</span>()) {
      val str = <span class="keyword">in</span><span class="preprocessor">.next</span>()<span class="comment">;</span>
      map(str) = (map<span class="preprocessor">.getOrElse</span>(str, <span class="number">0</span>) + <span class="number">1</span>)<span class="comment">;</span>
    }
    
    println(map<span class="preprocessor">.mkString</span>(<span class="string">","</span>))<span class="comment">;</span>
  } 
}
</pre></td></tr></table></figure>

<p>\6. 定义一个链式哈希映射，将“Monday”映射到java.util.Calendar.MONDAY，依此类推加入其他日期。展示元素是以插入的顺序被访问的。 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre>object MapApp
{
  def main(args: Array[String])  = {
    val map = new scala<span class="preprocessor">.collection</span><span class="preprocessor">.mutable</span><span class="preprocessor">.LinkedHashMap</span>[String, Int]()<span class="comment">;</span>
    map(<span class="string">"Monday"</span>)    = java<span class="preprocessor">.util</span><span class="preprocessor">.Calendar</span><span class="preprocessor">.MONDAY</span><span class="comment">;</span>
    map(<span class="string">"Tuesday"</span>)   = java<span class="preprocessor">.util</span><span class="preprocessor">.Calendar</span><span class="preprocessor">.TUESDAY</span><span class="comment">;</span>
    map(<span class="string">"Wednesday"</span>) = java<span class="preprocessor">.util</span><span class="preprocessor">.Calendar</span><span class="preprocessor">.WEDNESDAY</span><span class="comment">;</span>
    map(<span class="string">"Thursday"</span>)  = java<span class="preprocessor">.util</span><span class="preprocessor">.Calendar</span><span class="preprocessor">.THURSDAY</span><span class="comment">;</span>
    map(<span class="string">"Friday"</span>)    = java<span class="preprocessor">.util</span><span class="preprocessor">.Calendar</span><span class="preprocessor">.FRIDAY</span><span class="comment">;</span>
    map(<span class="string">"Saturday"</span>)  = java<span class="preprocessor">.util</span><span class="preprocessor">.Calendar</span><span class="preprocessor">.SATURDAY</span><span class="comment">;</span>
    map(<span class="string">"Sunday"</span>)    = java<span class="preprocessor">.util</span><span class="preprocessor">.Calendar</span><span class="preprocessor">.SUNDAY</span><span class="comment">;</span>
    
    println(map<span class="preprocessor">.mkString</span>(<span class="string">","</span>))
  }
}
</pre></td></tr></table></figure>

<p>\7. 打印出所有Java系统属性的表格。 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="keyword">import</span> scala.collection.JavaConversions.propertiesAsScalaMap
object MapApp
{
  def main(args: Array[String])  = {
    val props : scala.collection.Map[String, String] = System.getProperties()
    <span class="keyword">var</span> <span class="built_in">len</span> =<span class="number"> 0</span>;
    <span class="keyword">for</span> ((i, _) &lt;- props) {
      <span class="keyword">if</span> (<span class="built_in">len</span> &lt; i.length) {
        <span class="built_in">len</span> = i.length
      }        
    }          

    <span class="keyword">for</span> ((k, v) &lt;- props) {
      <span class="built_in">print</span>(k)
      <span class="built_in">print</span>(<span class="string">" "</span> * (<span class="built_in">len</span> - k.length))
      <span class="built_in">print</span>(<span class="string">" | "</span>)
      <span class="built_in">println</span>(v)
    }
  }
}
</pre></td></tr></table></figure>

<p>\8. 编写一个函数minmax(values: Array[Int]），返回数组中最小值和最大值的对偶。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre>object MapApp
{
  def main(args: Array[String])  = {
    val test = Array(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)
    val <span class="built_in">result</span> = minmax(test)
    println(<span class="built_in">result</span>.<span class="title">_1</span>)
    println(<span class="built_in">result</span>.<span class="title">_2</span>)
  } 
  
  def minmax(values : Array[Int]) = {
    val <span class="built_in">max</span> = values.<span class="built_in">max</span>
    val <span class="built_in">min</span> = values.<span class="built_in">min</span>
    (<span class="built_in">max</span>, <span class="built_in">min</span>)
  }
}
</pre></td></tr></table></figure>

<p>\9. 编写一个函数lteqgt(values: Array[Int], v: Int)，返回数组中小于v，等于v和大于v的数量，要求三个值一起返回。 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre>object MapApp
{
  def main(args: Array[String])  = {
    val test = Array(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)
    val result = lteqgt(test, <span class="number">3</span>)
    println(result)
  } 
  
  def lteqgt(<span class="keyword">values</span> : Array[Int], n : Int) = {
    var <span class="keyword">lt</span>, eq, <span class="keyword">gt</span> = <span class="number">0</span>
    <span class="keyword">for</span> (v &lt;- <span class="keyword">values</span>) {
      <span class="keyword">if</span> (v &gt; n) {
        <span class="keyword">gt</span> += <span class="number">1</span>; 
      } <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; n) {
        <span class="keyword">lt</span> += <span class="number">1</span>;
      } <span class="keyword">else</span> {
        eq += <span class="number">1</span>;
      } 
    } 
    
    (<span class="keyword">lt</span>, eq, <span class="keyword">gt</span>)
  } 
}
</pre></td></tr></table></figure>

<p>\10. 当你将两个字符串拉链在一起，比如”Hello”.zip(“World”)，会是什么结果？想出一个讲得通的用例。 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">MapApp</span></span>
{
  <span class="keyword">def</span> main(args: Array[String])  = {
    <span class="keyword">var</span> t1 = <span class="string">"hello"</span>.zip(<span class="string">" world"</span>);
    <span class="keyword">var</span> t2 = <span class="string">"ab"</span>.zip(<span class="string">"cdef"</span>);
    <span class="keyword">var</span> t3 = <span class="string">"abc"</span>.zip(<span class="string">"d"</span>);
    println(t1)
    println(t2)
    println(t3)
  }
}
</pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="function">Vector((h, )</span>, (e,w), (l,o), (l,r), (o,l))
<span class="function">Vector((a,c)</span>, (<span class="tag">b</span>,d))
<span class="function">Vector((a,d)</span>)
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="scala" scheme="http://www.swanlinux.net/tags/scala/"/>
    
      <category term="《快学scala》练习" scheme="http://www.swanlinux.net/categories/%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《快学scala》第三章 数组相关操作]]></title>
    <link href="http://www.swanlinux.net/2014/09/05/scala_note_3/"/>
    <id>http://www.swanlinux.net/2014/09/05/scala_note_3/</id>
    <published>2014-09-05T15:13:16.000Z</published>
    <updated>2015-05-23T22:03:07.643Z</updated>
    <content type="html"><![CDATA[<p>\1. 编写一段代码，将a设置为一个n个随机整数的数组，要求随机数介于0和n之间。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">App</span></span>
{
  <span class="keyword">def</span> main(args: Array[String]) {
    makeArr(<span class="number">10</span>).foreach(println);
  } 
   
  <span class="keyword">def</span> makeArr(n : Int) : Array[Int] = {
    <span class="keyword">val</span> a = <span class="keyword">new</span> Array[Int](n);
    <span class="keyword">val</span> rand = <span class="keyword">new</span> scala.util.Random();
    <span class="keyword">for</span> (i &lt;- a) <span class="keyword">yield</span> rand.nextInt(n);
  }                   
}
</pre></td></tr></table></figure>

<p>\2. 编写一个循环，将整数数组中相邻的元素置换。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">App</span></span>
{
  <span class="keyword">def</span> main(args: Array[String]) {
    <span class="keyword">val</span> a = Array(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);
    revert(a);
    a.foreach(println);
  } 
  
  <span class="keyword">def</span> revert(arr : Array[Int]) = {
    <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until (arr.length - <span class="number">1</span>, <span class="number">2</span>)) {
      <span class="keyword">val</span> t = arr(i);
      arr(i) = arr(i + <span class="number">1</span>);
      arr(i + <span class="number">1</span>) = t;
    } 
  } 
}
</pre></td></tr></table></figure>

<p>\3. 重复前一个练习，不过这次生成一个新的值交换过的数组。用for/yield。 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">App</span></span>
{
  <span class="keyword">def</span> main(args: Array[String]) {
    <span class="keyword">val</span> a = Array(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);
    <span class="keyword">val</span> b = revertYield(a);
    b.foreach(println);
  }

  <span class="keyword">def</span> revertYield(arr : Array[Int]) = {
    <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until arr.length) <span class="keyword">yield</span> {
      <span class="keyword">if</span> (i &lt; (arr.length - <span class="number">1</span>) && i % <span class="number">2</span> == <span class="number">0</span>) {
        <span class="keyword">val</span> t = arr(i);
        arr(i) = arr(i + <span class="number">1</span>);
        arr(i + <span class="number">1</span>) = t;
      } 
      arr(i);
    } 
  } 
}
</pre></td></tr></table></figure>

<p>\4.  给定一个整数数组，产出一个新的数组，包含元数组中的所有正值，以原有顺序排列，之后的元素是所有零或负值，以原有顺序排列。 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="keyword">import</span> scala.collection.mutable.ArrayBuffer

<span class="class"><span class="keyword">object</span> <span class="title">App</span></span>
{
  <span class="keyword">def</span> main(args: Array[String]) {
    <span class="keyword">val</span> a = Array(<span class="number">1</span>, -<span class="number">2</span>, <span class="number">0</span>, -<span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>);
    <span class="keyword">val</span> b = sigNumArr(a);
    b.foreach(println);
  }
  <span class="keyword">def</span> sigNumArr(arr : Array[Int]) = {
    <span class="keyword">val</span> buf = <span class="keyword">new</span> ArrayBuffer[Int]();
    buf ++= (<span class="keyword">for</span> (i &lt;- arr <span class="keyword">if</span> i &gt; <span class="number">0</span>) <span class="keyword">yield</span> i)
    buf ++= (<span class="keyword">for</span> (i &lt;- arr <span class="keyword">if</span> i == <span class="number">0</span>) <span class="keyword">yield</span> i)
    buf ++= (<span class="keyword">for</span> (i &lt;- arr <span class="keyword">if</span> i &lt; <span class="number">0</span>) <span class="keyword">yield</span> i)

    buf.toArray
  }
}
</pre></td></tr></table></figure>

<p>\5. 如何计算Array[Double]的平均值？ </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">App</span></span>
{
  <span class="keyword">def</span> main(args: Array[String])  = {
    <span class="keyword">val</span> a = Array(<span class="number">1.0</span>, -<span class="number">2.0</span>, <span class="number">0.0</span>, -<span class="number">3.0</span>, <span class="number">0.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>);
    <span class="keyword">val</span> b = avgArr(a);
    println(b)
  }

  <span class="keyword">def</span> avgArr(arr : Array[Double]) = {
    arr.sum / arr.length          
  } 
}
</pre></td></tr></table></figure>

<p>\6. 如何重新组织Array[Int]的元素将它们反序排列？对于ArrayBuffer[Int]你又会怎么做呢？  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="keyword">import</span> scala.collection.mutable.ArrayBuffer

<span class="class"><span class="keyword">object</span> <span class="title">App</span></span>
{
  <span class="keyword">def</span> main(args: Array[String])  = {
    <span class="keyword">val</span> a = Array(<span class="number">1</span>, -<span class="number">2</span>, <span class="number">0</span>, -<span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>);
    revertArray(a);
    a.foreach(println)
   
    <span class="comment">// ArrayBuffer 反转</span>
    <span class="keyword">val</span> b = ArrayBuffer(<span class="number">1</span>, -<span class="number">2</span>, <span class="number">0</span>, -<span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>);
    <span class="keyword">val</span> c = ArrayBuffer[Int]()
    c ++= b.reverse
    c.foreach(println)
  }  
     
  <span class="keyword">def</span> revertArray(arr : Array[Int]) = {
    <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until (arr.length % <span class="number">2</span>)) {
      <span class="keyword">val</span> t = arr(i); 
      arr(i) = arr(arr.length - <span class="number">1</span> - i);
      arr(arr.length - <span class="number">1</span> - i) = t;
    } 
  } 
}
</pre></td></tr></table></figure>

<p>\7. 编写一段代码，产出数组中的所有值，去掉重复项。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">import</span> scala.collection.mutable.ArrayBuffer

<span class="class"><span class="keyword">object</span> <span class="title">App</span></span>
{
  <span class="keyword">def</span> main(args: Array[String])  = {
    <span class="comment">// ArrayBuffer 排重</span>
    <span class="keyword">val</span> b = ArrayBuffer(<span class="number">1</span>, -<span class="number">2</span>, <span class="number">0</span>, -<span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>);
    <span class="keyword">val</span> c = ArrayBuffer[Int]() 
    c ++= b.distinct
    c.foreach(println)
  } 
}
</pre></td></tr></table></figure>

<p>\8. 重新编写3.4节结尾的示例。收集负值元素的下标，反序，去掉最后一个下标，然后对每一个下标调用a.remove(i)。比较这样做的效率和3.4节中另外两种方法的效率。 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="keyword">import</span> scala.collection.mutable.ArrayBuffer

<span class="class"><span class="keyword">object</span> <span class="title">App</span></span>
{
  <span class="keyword">def</span> main(args: Array[String])  = {
    <span class="keyword">val</span> b = Array(<span class="number">1</span>, -<span class="number">2</span>, <span class="number">0</span>, -<span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>);
    <span class="keyword">val</span> c = deleteUnFirstF(b)
    c.foreach(println)
  } 
  
  <span class="keyword">def</span> deleteUnFirstF(arr : Array[Int]) = {
    <span class="keyword">val</span> indexes = (<span class="keyword">for</span> (i &lt;- <span class="number">0</span> until arr.length <span class="keyword">if</span> arr(i) &lt; <span class="number">0</span>) <span class="keyword">yield</span> i)
    <span class="keyword">val</span> rights  = indexes.reverse.dropRight(<span class="number">1</span>)
    <span class="keyword">val</span> tmp = arr.toBuffer
    <span class="keyword">for</span> (index &lt;- rights) tmp.remove(index)
    tmp 
  }
}
</pre></td></tr></table></figure>

<p>\9. 创建一个由java.util.TimeZone.getAvailableIDs返回的时区集合，判断条件是它们在美洲，去掉”America/“前缀并排序。 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre>import scala<span class="preprocessor">.collection</span><span class="preprocessor">.mutable</span><span class="preprocessor">.ArrayBuffer</span>
import scala<span class="preprocessor">.collection</span><span class="preprocessor">.JavaConversions</span><span class="preprocessor">.asScalaBuffer</span>

object App
{
  def main(args: Array[String])  = {
    var c = timeZoneName()
    c<span class="preprocessor">.foreach</span>(println)
  }        
  
  def timeZoneName() = {
    val arr = java<span class="preprocessor">.util</span><span class="preprocessor">.TimeZone</span><span class="preprocessor">.getAvailableIDs</span>()<span class="comment">;</span>
    val tmp = (for (i &lt;- arr if i<span class="preprocessor">.startsWith</span>(<span class="string">"America/"</span>)) yield {
      i<span class="preprocessor">.drop</span>(<span class="string">"America/"</span><span class="preprocessor">.length</span>)
    })
    scala<span class="preprocessor">.util</span><span class="preprocessor">.Sorting</span><span class="preprocessor">.quickSort</span>(tmp)
    tmp
  }
}
</pre></td></tr></table></figure>

<p>\10. 引入java.awt.datatransfer._并构建一个类型为SystemFlavorMap类型的对象，然后以DataFlavor.imageFlavor为参数调用getNativesForFlavor方法，以Scala缓冲保存返回值。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>import scala<span class="preprocessor">.collection</span><span class="preprocessor">.JavaConversions</span><span class="preprocessor">.asScalaBuffer</span>
import scala<span class="preprocessor">.collection</span><span class="preprocessor">.mutable</span><span class="preprocessor">.Buffer</span>
import java<span class="preprocessor">.awt</span><span class="preprocessor">.datatransfer</span>._

object App
{
  def main(args: Array[String])  = {
     val flavors = SystemFlavorMap<span class="preprocessor">.getDefaultFlavorMap</span>()<span class="preprocessor">.asInstanceOf</span>[SystemFlavorMap]
     val buf : Buffer[String] = flavors<span class="preprocessor">.getNativesForFlavor</span>(DataFlavor<span class="preprocessor">.imageFlavor</span>)<span class="comment">;</span>
     buf<span class="preprocessor">.foreach</span>(println)<span class="comment">;</span>
  }
}
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="scala" scheme="http://www.swanlinux.net/tags/scala/"/>
    
      <category term="《快学scala》练习" scheme="http://www.swanlinux.net/categories/%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《快学scala》第二章 控制结构和函数]]></title>
    <link href="http://www.swanlinux.net/2014/09/05/scala_note_2/"/>
    <id>http://www.swanlinux.net/2014/09/05/scala_note_2/</id>
    <published>2014-09-05T07:13:16.000Z</published>
    <updated>2015-05-23T22:03:07.643Z</updated>
    <content type="html"><![CDATA[<p>\1. 一个数字如果为正数，则它的signum为1；如果是负数，则signum为-1；如果是0，则signum为0.编写一个函数来计算这个值。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="function"><span class="keyword">def</span> <span class="title">signum</span><span class="params">(x : Int)</span> :</span> Int = {
     <span class="keyword">if</span> (x &gt; <span class="number">0</span>) { 
       <span class="number">1</span>
     } <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">0</span>) {
       <span class="number">0</span>
     } <span class="keyword">else</span> {
       -<span class="number">1</span>
     } 
}
</pre></td></tr></table></figure>

<p>\2. 一个空的块表达式{}的值是什么？类型是什么？ </p>
<p>没有值<br>类型为 Unit</p>
<p>\3. 指出在Scala中何种情况下赋值语句x = y = 1是合法的。（提示：给x找个合适的类型定义。）</p>
<p>x 为 Unit 类型</p>
<p>\4. 针对下列Java循环编写一个scala版, for (int i = 10; i &gt;= 0; i—) System.out.println(i);</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>def forTest(x : <span class="built_in">Int</span>) = {
  <span class="keyword">for</span> (i &lt;- x.<span class="keyword">to</span>(<span class="number">0</span>, -<span class="number">1</span>)) {
	println(i);
  }
}
</pre></td></tr></table></figure>

<p>\5. 编写一个过程countdown(n:Int)，打印从n到0的数字</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>object App
{
	def main(args: Array[String]) {
	  countdown(10);
	} 

	def countdown(x : Int) = {
	  for (i &lt;- x.to(0, -1)) {
		println(i);
	  } 
	} 
}
</pre></td></tr></table></figure>

<p>\6. 编写一个for循环，计算字符串中所有字母的Unicode代码的乘积。 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">TestWDO</span></span>
{
  <span class="keyword">def</span> main(args : Array[String]) {
      <span class="keyword">val</span> str = <span class="string">"hello"</span>;
      <span class="keyword">var</span> result = <span class="number">1</span>;
      <span class="keyword">for</span> (i &lt;- str) {
        result *= i.toInt
      }

      println(result);
  }
}
</pre></td></tr></table></figure>

<p>\7. 同样是解决前一个练习的问题，但这次不使用循环。 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">TestWDO</span></span>
{
  <span class="keyword">def</span> main(args : Array[String]) {
      <span class="keyword">val</span> str = <span class="string">"hello"</span>;
      <span class="keyword">var</span> result = <span class="number">1</span>;
      str.foreach(result *= _.toInt)
      println(result);
  }
}
</pre></td></tr></table></figure>

<p>\8. 编写一个函数product(s: string)，计算前面练习中提过的乘积。 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">TestWDO</span></span>
{
  <span class="keyword">def</span> main(args : Array[String]) {
      <span class="keyword">val</span> str = <span class="string">"hello"</span>;
      <span class="keyword">var</span> result = <span class="number">1</span>;
      result = product(str)
      println(result);
  }           
  
  <span class="keyword">def</span> product(s : String) = {
    s.map(_.toInt).product
  }
}
</pre></td></tr></table></figure>

<p>\9. 把前一个练习中的函数改成递归函数。 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="class"><span class="keyword">object</span> <span class="title">TestWDO</span></span>
{
  <span class="keyword">def</span> main(args : Array[String]) {
      <span class="keyword">val</span> str = <span class="string">"hello"</span>;
      <span class="keyword">var</span> result = <span class="number">1</span>;
      result = product(str)
      println(result);
  }           
  
  <span class="keyword">def</span> product(s : String) : Int = {
    <span class="keyword">if</span> (s.length == <span class="number">1</span>) {
      s(<span class="number">0</span>).toInt
    } <span class="keyword">else</span> {
      s(<span class="number">0</span>).toInt * product(s.substring(<span class="number">1</span>));
    }
  } 
}
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="scala" scheme="http://www.swanlinux.net/tags/scala/"/>
    
      <category term="《快学scala》练习" scheme="http://www.swanlinux.net/categories/%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《快学scala》第一章 基础]]></title>
    <link href="http://www.swanlinux.net/2014/09/05/scala_note_1/"/>
    <id>http://www.swanlinux.net/2014/09/05/scala_note_1/</id>
    <published>2014-09-05T05:13:16.000Z</published>
    <updated>2015-05-23T22:03:07.642Z</updated>
    <content type="html"><![CDATA[<p>\1. 在 Scala REPL 中键入3，然后按TAB键。有那些方法可以被应用？ </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>scala&gt; 3.
!=<span class="ruby">             <span class="comment">##             %              &              *              +              -              /              </span>
</span>&lt;              &lt;&lt;             &lt;=             &lt;init&gt;         ==             &gt;              &gt;=             &gt;&gt;             
&gt;&gt;&gt;            ^              asInstanceOf   equals         getClass       hashCode       isInstanceOf   toByte         
toChar         toDouble       toFloat        toInt          toLong         toShort        toString       unary_+        
unary_-        unary_~        |
</pre></td></tr></table></figure>

<p>\2. 在scala REPL中，计算3的平方根，然后再对该值求平方，现在，这个结果与3相差多少？（提示：res变量是你的朋友）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>scala&gt; import scala<span class="preprocessor">.math</span>._
import scala<span class="preprocessor">.math</span>._

scala&gt; sqrt(<span class="number">3</span>)
<span class="label">res0:</span> Double = <span class="number">1.7320508075688772</span>

scala&gt; pow(res0, <span class="number">2</span>)
<span class="label">res1:</span> Double = <span class="number">2.9999999999999996</span>

scala&gt; <span class="number">3</span> - res1
<span class="label">res3:</span> Double = <span class="number">4.440892098500626E-16</span>
</pre></td></tr></table></figure>

<p>\3. res变量是val还是var？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">val</span>
</pre></td></tr></table></figure>

<p>\4. Scala 允许你用数字去乘字符串—去 REPL中试一下 “crazy” * 3, 这个操作做什么？在 Scaladoc 中如何找到这个操作？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>scala&gt; <span class="string">"crazy"</span> * <span class="number">3</span>
res4: String = crazycrazycrazy

<span class="function"><span class="keyword">def</span> *<span class="params">(n: Int)</span>:</span> String

Return the current string concatenated n times.
</pre></td></tr></table></figure>


<p>\5. 10 max 2的含义是什么？max方法定义在哪个类中？ </p>
<p>含义： 10.max(2)</p>
<p>max 方法定义在 RichInt -&gt; ScalaNumberProxy</p>
<p>\6. 用BigInt计算2的1024次方。 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>scala&gt; val <span class="built_in">x</span> : BigInt = <span class="number">2</span>
<span class="label">x:</span> scala<span class="preprocessor">.math</span><span class="preprocessor">.BigInt</span> = <span class="number">2</span>

scala&gt; <span class="built_in">x</span><span class="preprocessor">.pow</span>(<span class="number">1024</span>)
<span class="label">res5:</span> scala<span class="preprocessor">.math</span><span class="preprocessor">.BigInt</span> = <span class="number">179769313486231590772930519078902473361797697894230657273430081157732675805500963132708477322407536021120113879871393357658789768814416622492847430639474124377767893424865485276302219601246094119453082952085005768838150682342462881473913110540827237163350510684586298239947245938479716304835356329624224137216</span>
</pre></td></tr></table></figure>

<p>\7. 为了在使用probablePrime(100, Random)获取随机素数时不在probablePrime和Radom之前使用任何限定符，你需要引入什么？ </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>scala&gt; import scala<span class="preprocessor">.util</span>._
import scala<span class="preprocessor">.util</span>._

scala&gt; import scala<span class="preprocessor">.math</span><span class="preprocessor">.BigInt</span>._
import scala<span class="preprocessor">.math</span><span class="preprocessor">.BigInt</span>._

scala&gt; 

scala&gt; 

scala&gt; probablePrime(<span class="number">100</span>, Random)
<span class="label">res6:</span> scala<span class="preprocessor">.math</span><span class="preprocessor">.BigInt</span> = <span class="number">1139920916542977579379440009349</span>
</pre></td></tr></table></figure>

<p>\8. 创建随机文件的方式之一是生成一个随机的BigInt，然后把它转换成三十六进制，输出类似”qsnveffwfweq434ojjlk”这样的字符串，查阅scaladoc，找到在scala中实现该逻辑的办法。 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>scala&gt; val <span class="built_in">x</span> : BigInt = probablePrime(<span class="number">100</span>, Random)
<span class="label">x:</span> scala<span class="preprocessor">.math</span><span class="preprocessor">.BigInt</span> = <span class="number">1241670916639639181026223834111</span>

scala&gt; <span class="built_in">x</span><span class="preprocessor">.toString</span>(<span class="number">36</span>)
<span class="label">res18:</span> String = <span class="number">3</span>cdr1tpupxgeogbs2ynz
</pre></td></tr></table></figure>

<p>\9. 在Scala中如何获取字符串的首字符和尾字符？ </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>scala&gt; val str : String = <span class="string">"abcdef"</span>
<span class="label">str:</span> String = abcdef

scala&gt; str<span class="preprocessor">.head</span>
<span class="label">res19:</span> Char = a

scala&gt; str<span class="preprocessor">.last</span>
<span class="label">res20:</span> Char = f
</pre></td></tr></table></figure>

<p>\10.  take, drop, takeRight, dropRight这些字符串函数是做什么用的？和substring相比，它们的优点和缺点都有哪些？ </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>scala&gt; val str : String = <span class="string">"abcdef"</span>
<span class="label">str:</span> String = abcdef

scala&gt; str<span class="preprocessor">.take</span>(<span class="number">2</span>)
<span class="label">res21:</span> String = ab

scala&gt; str<span class="preprocessor">.drop</span>(<span class="number">2</span>)
<span class="label">res22:</span> String = cdef

scala&gt; str<span class="preprocessor">.takeRight</span>(<span class="number">2</span>)
<span class="label">res23:</span> String = ef

scala&gt; str<span class="preprocessor">.dropRight</span>(<span class="number">2</span>)
<span class="label">res24:</span> String = abcd
</pre></td></tr></table></figure>

]]></content>
    
    
      <category term="scala" scheme="http://www.swanlinux.net/tags/scala/"/>
    
      <category term="《快学scala》练习" scheme="http://www.swanlinux.net/categories/%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[安装 ESXI]]></title>
    <link href="http://www.swanlinux.net/2014/04/11/vm_esxi_install/"/>
    <id>http://www.swanlinux.net/2014/04/11/vm_esxi_install/</id>
    <published>2014-04-11T15:13:16.000Z</published>
    <updated>2015-05-23T22:03:07.644Z</updated>
    <content type="html"><![CDATA[<h3 id="硬件环境">硬件环境</h3>
<p>主板：华硕P8B75 <strong>板载Realtek RTL8111F千兆网卡</strong> 注意：RLT类型的网卡 VM默认安装不支持，需要重新打包安装（下面详细说明）<br>CPU: 英特尔 第三代酷睿 i5-3570K @ 3.40GHz<br>内存: 16 GB</p>
<h3 id="用到的软件下载">用到的软件下载</h3>
<ul>
<li><a href="https://my.vmware.com/cn/web/vmware/info/slug/datacenter_cloud_infrastructure/vmware_vsphere/5_5" target="_blank">VMware-VMvisor-Installer-5.5.0.update01-1623387.x86_64.iso</a></li>
<li><a href="http://pan.baidu.com/s/1kTkcCv1" target="_blank">rufus-1.4.6</a></li>
<li><a href="http://pan.baidu.com/s/1eQwyc8a" target="_blank">ESXi-Customizer-v2.7.1</a></li>
<li><a href="http://pan.baidu.com/s/1rM2We" target="_blank">VMware_bootbank_net-r8168_8.013.00-3vmw.510.0.0.799733.vib</a></li>
</ul>
<h4 id="制作_U盘安装镜像">制作 U盘安装镜像</h4>
<p>首先将 RLT 网卡驱动打包进安装包中，需要用到 ESXi-Customizer 软件，具体步骤如下：</p>
<p><img src="/image/vm/vm-esxi-001-001.jpg" alt="自定义安装包"></p>
<p>将打包出来的软件安装包 ISO 文件利用 rufus 安装到U盘中，具体步骤如下：</p>
<p>选择镜像文件<br><img src="/image/vm/vm-esxi-003-001.png" alt="制作U盘安装盘"></p>
<p>当开始制作的时候会弹出如下的提示：</p>
<p><img src="/image/vm/vm-esxi-002-001.png" alt="选择 NO 不修改现有的镜像"></p>
<h4 id="安装_ESXI">安装 ESXI</h4>
<h4 id="安装_VMware-viclient">安装 VMware-viclient</h4>
<p>安装好 ESXI server 后，可以用 client进行管理 server，进行虚拟机安装</p>
]]></content>
    
    
      <category term="esxi" scheme="http://www.swanlinux.net/tags/esxi/"/>
    
      <category term="虚拟技术" scheme="http://www.swanlinux.net/categories/%E8%99%9A%E6%8B%9F%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
</feed>
